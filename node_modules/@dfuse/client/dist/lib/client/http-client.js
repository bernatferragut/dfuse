"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("../types/error");
const debug_1 = __importDefault(require("debug"));
/**
 * Create the default [[HttpClient]] concrete implementation.
 *
 * @param authUrl The full dfuse Authentication url to use to perform the `authRequest` calls.
 * @param apiUrl The full dfuse REST API url to use to perform the `apiRequest` calls.
 * @param options The set of options used to construct the default [[HttpClient]] instance. See
 * [[HttpClientOptions]] for documentation of the options and default values for each of them.
 */
function createHttpClient(authUrl, apiUrl, options = {}) {
    return new DefaultHttpClient(authUrl, apiUrl, inferFetch(options.fetch));
}
exports.createHttpClient = createHttpClient;
function inferFetch(fetch) {
    const debug = debug_1.default("dfuse:http");
    if (fetch !== undefined) {
        debug("Using user provided `fetch` option.");
        return fetch;
    }
    // In both of the condition below to determine a global `fetch` to use,
    // we bind the `fetch` method to the global scope (either `window` or `global`
    // depending on the target environment).
    //
    // It happens in a bundler environment like WebPack that the `fetch` method
    // loses it's contextual `this` variable. The `this` is used internal by the
    // implementation for certain features of the specification.
    //
    // By doing a `.bind(<global scope>)`, we ensure the `fetch` remains bound
    // to the correct `this` variable.
    // If we are in a Browser environment and `fetch` is available, use it
    if (typeof window !== "undefined" && window.fetch != null) {
        debug("Using `fetch` global value found on 'window' variable (Browser environment).");
        return window.fetch.bind(window);
    }
    // If we are in a Node.js like environment and `fetch` is available, use it
    if (typeof global !== "undefined" && global.fetch != null) {
        debug("Using `fetch` global value found on 'global' variable (Node.js environment).");
        return global.fetch.bind(global);
    }
    // Otherwise, throw an exception
    const messages = [
        "You did not provide a `fetch` option and we were not able to infer one from the global scope.",
        "",
        "You are most likely in a Node.js environment where a global `fetch` is not available by defaut.",
        "To resolve the issue, either pass a compatible `fetch` option or globally defined a `global.fetch`",
        "variable pointing to a compatible `fetch` method.",
        "",
        "We invite you to read our documentation to learn more about this problem.",
        "",
        "See https://github.com/dfuse-io/client-js#nodejs"
    ];
    throw new error_1.DfuseClientError(messages.join("\n"));
}
/**
 * The `DefaultHttpClient` is responsible of performing the actual HTTP
 * calls transforming the parameters into an actual HTTP request and
 * turning back the HTTP response into a return value.
 *
 * All methods are asynchronous and returns a response object when successufl
 * and throws a `DfuseError` when an error is encountered.
 */
class DefaultHttpClient {
    constructor(authUrl, apiUrl, fetch) {
        this.debug = debug_1.default("dfuse:http");
        this.authUrl = authUrl;
        this.apiUrl = apiUrl;
        this.fetch = fetch;
    }
    release() {
        return;
    }
    authRequest(path, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(undefined, this.authUrl + path, method, params, body, headers);
        });
    }
    apiRequest(apiToken, path, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(apiToken, this.apiUrl + path, method, params, body, headers);
        });
    }
    request(apiToken, url, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("Preparing request [%s %s](%o)", method, url, params);
            if (params && Object.keys(params).length > 0) {
                url += "?" + this.queryParams(params);
            }
            const defaultHeaders = {};
            if (apiToken !== undefined) {
                defaultHeaders.Authorization = `Bearer ${apiToken}`;
            }
            const userHeaders = headers || {};
            const mergedHeaders = Object.assign(Object.assign({}, defaultHeaders), userHeaders);
            let transformedBody;
            if (body !== undefined) {
                const contentType = this.getHeaderValue(mergedHeaders, "content-type");
                if (contentType === undefined || contentType === "application/json") {
                    transformedBody = JSON.stringify(body);
                }
                else if (contentType === "application/x-www-form-urlencoded") {
                    transformedBody = this.formEncodedBody(body);
                }
                else {
                    transformedBody = body;
                }
            }
            try {
                this.debug("Executing request [%s %s](headers: %o, bodyLength: %s)", method, url, mergedHeaders, (transformedBody || "").length);
                const response = yield this.fetch(url, {
                    headers: mergedHeaders,
                    method,
                    body: transformedBody
                });
                this.debug("Received response [%s %s %s](headers: %o)", response.status, response.statusText, response.url, response.headers);
                if (!response.ok) {
                    this.debug("Request returned with an error HTTP code %s", response.status);
                    throw yield this.bodyToApiError(response);
                }
                this.debug("Turning response body into response result");
                return yield this.bodyToResponse(response);
            }
            catch (error) {
                if (error instanceof error_1.DfuseError) {
                    throw error;
                }
                throw new error_1.DfuseClientError("Unable to perform HTTP request correctly", error);
            }
        });
    }
    bodyToResponse(response) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield response.json();
            }
            catch (error) {
                throw new error_1.DfuseClientError("The returned body shall have been a valid JSON object", error);
            }
        });
    }
    bodyToApiError(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = yield response.text();
            try {
                return new error_1.DfuseApiError(JSON.parse(body));
            }
            catch (error) {
                return new error_1.DfuseClientError(`The returned body shall have been a valid JSON object, got '${body}'`, error);
            }
        });
    }
    queryParams(params) {
        const entries = [];
        for (const key of Object.keys(params)) {
            const value = params[key];
            if (value !== undefined) {
                entries.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }
        }
        return entries.join("&");
    }
    formEncodedBody(fields) {
        const entries = [];
        for (const key of Object.keys(fields)) {
            const value = fields[key];
            if (value !== undefined) {
                entries.push(key + "=" + value);
            }
        }
        return entries.join("&");
    }
    // FIXME: In real world scenario, an HTTP header can appear more than onced, but we do not
    //        deal with this case here yet.
    getHeaderValue(headers, key) {
        for (const candidateKey in headers) {
            if (candidateKey.toLowerCase() === key.toLowerCase()) {
                return headers[candidateKey];
            }
        }
        return undefined;
    }
    hasHeaderKey(headers, key) {
        return this.getHeaderValue(headers, key) !== undefined;
    }
}
//# sourceMappingURL=http-client.js.map