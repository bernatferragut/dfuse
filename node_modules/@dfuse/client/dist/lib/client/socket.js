"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const error_1 = require("../types/error");
/**
 * Create an actual [[Socket]] instance that will be used as the interface to wrap all
 * communicaton of the WebSocket protocol.
 *
 * @param url The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter.
 * @param options The options used to configure the [[Socket]] instance, see [[SocketOptions]] for default options.
 */
function createSocket(url, options = {}) {
    return new DefaultSocket(url, Object.assign({ id: "", autoReconnect: true, reconnectDelayInMs: exports.DEFAULT_RECONNECT_DELAY_IN_MS, keepAlive: true, keepAliveIntervalInMs: exports.DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS, webSocketFactory: inferWebSocketFactory(options.id, options.webSocketProtocols, options.webSocketFactory) }, options));
}
exports.createSocket = createSocket;
function inferWebSocketFactory(id, webSocketProtocols, webSocketFactory) {
    const debug = debug_1.default("dfuse:socket" + (id ? `:${id}` : ""));
    if (webSocketFactory !== undefined) {
        debug("Using user provided `webSocketFactory` option.");
        return webSocketFactory;
    }
    // If we are in a Browser environment and `WebSocket` is available, use it
    if (typeof window !== "undefined" && window.WebSocket != null) {
        debug("Using `WebSocket` global value found on 'window' variable (Browser environment).");
        return (url) => __awaiter(this, void 0, void 0, function* () { return new window.WebSocket(url, webSocketProtocols); });
    }
    // If we are in a Node.js like environment and `WebSocket` is available, use it
    if (typeof global !== "undefined" && global.WebSocket != null) {
        debug("Using `WebSocket` global value found on 'global' variable (Node.js environment).");
        return (url) => __awaiter(this, void 0, void 0, function* () { return new global.WebSocket(url, webSocketProtocols, {}); });
    }
    // Otherwise, throw an exception
    const messages = [
        "You did not provide a `webSocket` option and we were not able find a `WebSocket` object in",
        "the global scope to create use.",
        "",
        "You are most likely in a Node.js environment where a global `WebSocket` is not available by default.",
        "To resolve the issue, either pass a compatible `webSocket` option or globally defined a `global.WebSocket`",
        "variable pointing to a compatible `WebSocket` client.",
        "",
        "We invite you to read our documentation to learn more about this problem.",
        "",
        "See https://github.com/dfuse-io/client-js#nodejs"
    ];
    throw new error_1.DfuseClientError(messages.join("\n"));
}
const noop = () => {
    return;
};
exports.DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS = 30000; // 30s
exports.DEFAULT_RECONNECT_DELAY_IN_MS = 2500; // 2.5s
class DefaultSocket {
    constructor(url, options) {
        this.isConnected = false;
        this.onSocketConnectOpenFactory = (resolve) => () => {
            this.debug("Received `onopen` (via connect) notification from socket.");
            this.isConnected = true;
            this.connectionPromise = undefined;
            if (this.keepAliveOption() === true) {
                this.registerKeepAliveHandler();
            }
            this.debug("Signaling completion of `connect` method in the outer scope.");
            resolve();
        };
        this.onSocketReconnectOpenFactory = (resolve) => () => {
            this.debug("Received `onopen` (via reconnect) notification from socket with ready state %d.", this.socket.readyState);
            this.isConnected = true;
            this.connectionPromise = undefined;
            if (this.keepAliveOption() === true) {
                this.registerKeepAliveHandler();
            }
            this.debug("Signaling completion of `reconnect` method in the outer scope.");
            resolve(true);
            this.debug("Sending a `onReconnect` notification to client consumer.");
            this.onReconnect();
        };
        this.onSocketErrorFactory = (reject) => (event) => {
            this.debug("Received `onerror` notification from socket (%s).", event.error);
            // The official WebSocket flow is to always send an `onclose` event after an `onerror`
            // ones, as such, we must not clean the socket at this point. We must always
            // wait and ensures the `onclose` event will be called and that clean up will
            // happen in the `onclose` handler.
            this.debug("Signaling rejection of connection in the outer scope.");
            reject(event);
            this.debug("Sending an `onError` notification to client consumer.");
            this.onError(event);
        };
        this.onSocketReconnectErrorFactory = () => (event) => {
            this.debug("Received `onerror` (via reconnect) notification from socket.");
            this.debug("Sending an `onError` notification to client consumer.");
            this.onError(event);
        };
        this.onSocketCloseFactory = () => {
            return this.commonOnSocketCloseFactory("connect", () => {
                this.reconnect().catch((error) => {
                    this.debug("The re-connection never succeed, will not retry anymore.", error);
                });
            });
        };
        this.onSocketReconnectCloseFactory = (resolve, reject) => {
            return this.commonOnSocketCloseFactory("reconnect", () => {
                this.tryReconnect(resolve, reject);
            });
        };
        this.commonOnSocketCloseFactory = (tag, reconnectWorker) => (event) => {
            this.debug("Received `onclose` (via %s) notification from socket.", tag);
            this.isConnected = false;
            this.connectionPromise = undefined;
            if (this.closeResolver) {
                this.debug("Resolving disconnect close promise (via %s).", tag);
                this.closeResolver();
                this.closeResolver = undefined;
                this.closePromise = undefined;
            }
            this.cleanSocket();
            this.debug("Sending a `onClose` (%d) notification to client consumer (via %s).", event.code, tag);
            this.onClose(event);
            if (event.code !== 1000 &&
                event.code !== 1009 &&
                this.disconnectInitiator !== "client" &&
                this.options.autoReconnect) {
                this.debug("Socket has close abnormally (via %s), trying to re-connect to socket (infinite retry).", tag);
                reconnectWorker();
            }
            else {
                this.debug("Terminating socket lifecycle (via %s), no reconnection will be attempted.", tag);
                if (this.onTerminationListener) {
                    this.onTerminationListener();
                }
                this.disconnectInitiator = undefined;
            }
        };
        this.onSocketMessage = (event) => {
            let message;
            try {
                message = JSON.parse(event.data);
            }
            catch (error) {
                this.debug("Received a non-JSON message, are you sure you are talking to dfuse API?");
                return;
            }
            if (this.listener) {
                this.listener(message);
            }
        };
        this.tryReconnect = (resolve, reject) => {
            let reconnectDelay = this.options.reconnectDelayInMs;
            if (reconnectDelay === undefined) {
                reconnectDelay = exports.DEFAULT_RECONNECT_DELAY_IN_MS;
            }
            this.debug(`Waiting ${reconnectDelay}ms before trying to perform the re-connection.`);
            setTimeout(() => {
                this.createAnOpenSocket(this.onSocketReconnectOpenFactory(resolve), this.onSocketReconnectErrorFactory(), this.onSocketReconnectCloseFactory(resolve, reject), reject);
            }, reconnectDelay);
        };
        this.url = url;
        this.options = options;
        this.debug = debug_1.default("dfuse:socket" + (options.id !== "" ? `:${options.id}` : ""));
    }
    setApiToken(apiToken) {
        this.debug("Socket API token updated to %s.", apiToken);
        this.apiToken = apiToken;
    }
    connect(listener, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to connect to remote endpoint.");
            if (this.connectionPromise !== undefined) {
                return this.connectionPromise;
            }
            if (this.isConnected) {
                return;
            }
            this.listener = listener;
            this.onReconnectListener = options.onReconnect;
            this.onTerminationListener = options.onTermination;
            this.connectionPromise = new Promise((resolve, reject) => {
                this.debug("Connection promise started, creating and opening socket.");
                this.createAnOpenSocket(this.onSocketConnectOpenFactory(resolve), this.onSocketErrorFactory(reject), this.onSocketCloseFactory(), reject);
            });
            this.debug("Connection to remote endpoint in-progress, returning promise to caller.");
            return this.connectionPromise;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to disconnect from remote endpoint.");
            if (this.closePromise) {
                this.debug("A disconnect is already in progress, joining it for termination.");
                return this.closePromise;
            }
            if (this.socket === undefined) {
                return;
            }
            this.onReconnectListener = undefined;
            this.listener = undefined;
            this.debug("Closing socket.");
            this.socket.close();
            // We must not clean up the socket at this point yet. Cleaning up the socket means
            // removing the actual event listeners. If you clean up just yet, the `onclose` event
            // will not be handled and the consumer of the library does not receive its own
            // `onClose` event. Instead, let's do the clean up once we receive the socket
            // `onclose` event.
            this.debug("Lazily disconnected, remaining clean up shall be performed when receiving `onclose` event.");
            this.isConnected = false;
            this.disconnectInitiator = "client";
            this.closePromise = new Promise((resolve) => {
                // Shall be resolved by the `onClose` event handler on this class
                this.closeResolver = resolve;
            });
            return this.closePromise;
        });
    }
    send(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected) {
                this.debug("Not connected, re-connecting prior sending message.");
                yield this.reconnect();
            }
            if (!this.isConnected) {
                this.debug("Socket not connected, unable to send message correctly.");
                throw new error_1.DfuseSocketError("Socket not connected, unable to send message correctly.");
            }
            this.debug("Sending message %o through socket.", message);
            this.socket.send(JSON.stringify(message));
        });
    }
    createAnOpenSocket(onSocketOpen, onSocketError, onSocketClose, onSocketFactoryError) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.buildUrl();
            this.debug("Starting connection handshake with remote url %s.", url);
            try {
                const socket = yield this.options.webSocketFactory(url);
                socket.onopen = onSocketOpen;
                socket.onerror = onSocketError;
                socket.onclose = onSocketClose;
                socket.onmessage = this.onSocketMessage;
                this.socket = socket;
            }
            catch (error) {
                onSocketFactoryError(error);
            }
        });
    }
    buildUrl() {
        if (this.apiToken === undefined) {
            // FIXME: Shall we throw an exception instead?
            return this.url;
        }
        // FIXME: Decompose url, add query param api token if available, then re-compose url!
        if (this.url.includes("?")) {
            return `${this.url}&token=${this.apiToken}`;
        }
        return `${this.url}?token=${this.apiToken}`;
    }
    registerKeepAliveHandler() {
        const keepAliveInterval = this.options.keepAliveIntervalInMs || exports.DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS;
        this.debug("Unregistering keep alive interval");
        this.intervalHandler = setInterval(() => {
            if (!this.isConnected || this.socket === undefined) {
                return;
            }
            this.debug("Sending keep alive pong through socket.");
            this.socket.send(JSON.stringify({ type: "pong" }));
        }, keepAliveInterval);
    }
    unregisterKeepAliveHandler() {
        if (this.intervalHandler === undefined) {
            return;
        }
        this.debug("Unregistering keep alive interval");
        clearInterval(this.intervalHandler);
        this.intervalHandler = undefined;
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("Reconnect has been invoked, perfoming initial re-connection logic.");
            if (this.connectionPromise) {
                try {
                    this.debug("Awaiting actual connection to complete.");
                    yield this.connectionPromise;
                    return true;
                }
                catch (error) {
                    this.debug("Original connection did not succeed, continuing re-connection process.");
                }
            }
            if (!this.options.autoReconnect) {
                this.debug("Not re-connecting because client consumer auto reconnect option is falsy.");
                return false;
            }
            return new Promise(this.tryReconnect);
        });
    }
    cleanSocket() {
        if (this.intervalHandler !== undefined) {
            this.unregisterKeepAliveHandler();
        }
        if (this.socket === undefined) {
            return;
        }
        this.socket.onopen = noop;
        this.socket.onclose = noop;
        this.socket.onerror = noop;
        this.socket.onmessage = noop;
        this.socket = undefined;
    }
    /**
     * We notify both the `onReconnect` option passed when constructing
     * the socket and the one (if present) that was passed when connecting
     * the socket.
     *
     * Those are two different listeners and must be both sent when possible.
     */
    onReconnect() {
        // Let's call the `connect` `onReconnectListener` first then followed
        // by the one the consumer of the socket passed
        if (this.onReconnectListener)
            this.onReconnectListener();
        if (this.options.onReconnect)
            this.options.onReconnect();
    }
    onClose(message) {
        if (this.options.onClose)
            this.options.onClose(message);
    }
    onError(message) {
        if (this.options.onError)
            this.options.onError(message);
    }
    keepAliveOption() {
        return this.options.keepAlive === undefined ? true : this.options.keepAlive;
    }
}
//# sourceMappingURL=socket.js.map