"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const socket_1 = require("./socket");
const outbound_1 = require("../message/outbound");
const inbound_1 = require("../message/inbound");
const error_1 = require("../types/error");
const promises_1 = require("../helpers/promises");
/**
 * Create the default [[StreamClient]] concrete implementation.
 *
 * @param wsUrl The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter. Passed as
 * is to created [[Socket]] interface through the [[createSocket]] factory method. This parameter has no effect
 * if [[StreamClientOptions.socket]] options is used.
 * @param options The set of options used to construct the default [[StreamClient]] instance. See
 * [[StreamClientOptions]] for documentation of the options and default values for each of them.
 */
function createStreamClient(wsUrl, options = {}) {
    return new DefaultStreamClient(options.socket || socket_1.createSocket(wsUrl, Object.assign({ id: "stream" }, options.socketOptions)), options.autoRestartStreamsOnReconnect === undefined
        ? true
        : options.autoRestartStreamsOnReconnect);
}
exports.createStreamClient = createStreamClient;
class DefaultStreamClient {
    constructor(socket, autoRestartStreamsOnReconnect) {
        this.debug = debug_1.default("dfuse:stream");
        this.debugTrace = debug_1.default("dfuse-trace:stream");
        this.streams = {};
        this.handleMessage = (rawMessage) => {
            const message = rawMessage;
            if (message.type === "ping") {
                this.debug("Discarding 'ping' message from reaching the underlying stream(s).");
                return;
            }
            let debug = this.debugTrace;
            if (message.type === inbound_1.InboundMessageType.ERROR ||
                message.type === inbound_1.InboundMessageType.LISTENING ||
                message.type === inbound_1.InboundMessageType.UNLISTENED) {
                debug = this.debug;
            }
            debug("Routing socket message of type '%s' with req_id '%s' to appropriate stream", message.type, message.req_id);
            const stream = this.streams[message.req_id || ""];
            if (stream === undefined) {
                this.debug("No stream currently registered able to handle message with req_id '%s'", message.req_id);
                return;
            }
            stream.onMessage(message, stream);
        };
        this.handleReconnection = () => {
            if (this.autoRestartStreamsOnReconnect === false) {
                return;
            }
            Object.keys(this.streams).forEach((streamId) => {
                this.streams[streamId].restart();
            });
        };
        this.socket = socket;
        this.autoRestartStreamsOnReconnect = autoRestartStreamsOnReconnect;
    }
    release() {
        this.debug("Releasing default stream client");
        this.socket.disconnect().catch((error) => {
            this.debug("An error occurred while disconnecting from socket while releasing instance", error);
        });
    }
    setApiToken(apiToken) {
        this.socket.setApiToken(apiToken);
    }
    registerStream(message, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.socket.isConnected) {
                this.debug("Socket is not connected, connecting socket first.");
                yield this.socket.connect(this.handleMessage, { onReconnect: this.handleReconnection });
            }
            const id = message.req_id;
            if (this.streams[id] !== undefined) {
                throw new error_1.DfuseClientError(`A stream with id '${id}' is already registered, cannot register another one with the same id`);
            }
            this.debug("Registering stream [%s] with message %o.", id, message);
            const streamExists = (streamId) => this.streams[streamId] !== undefined;
            const unregisterStream = (streamId) => this.unregisterStream(streamId);
            const stream = new DefaultStream(id, message, onMessage, streamExists, unregisterStream, this.socket, this.debug.extend(id, ":"));
            // Let's first register stream to ensure that if messages arrives before we got back
            // execution flow after `send` call, the listener is already present to handle message
            this.streams[id] = stream;
            try {
                yield stream.start();
            }
            catch (error) {
                delete this.streams[id];
                throw new error_1.DfuseClientError(`Unable to correctly register stream '${id}'`, error);
            }
            this.debug("Stream [%s] registered with remote endpoint.", id);
            return stream;
        });
    }
    unregisterStream(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.streams[id] === undefined) {
                this.debug("Stream [%s] is already unregistered, nothing to do.", id);
                return;
            }
            const message = outbound_1.unlistenMessage({ req_id: id });
            this.debug("Unregistering stream [%s] with message %o.", id, message);
            delete this.streams[id];
            if (this.socket.isConnected) {
                yield this.socket.send(message);
            }
            if (Object.keys(this.streams).length <= 0) {
                this.debug("No more stream present, disconnecting socket.");
                if (this.socket.isConnected) {
                    yield this.socket.disconnect();
                }
            }
        });
    }
}
class DefaultStream {
    constructor(id, registrationMessage, onMessage, streamExists, unregisterStream, socket, debug) {
        this.resolve = () => {
            if (this.activeJoiner) {
                this.debug("Resolving joiner promise.");
                this.activeJoiner.resolve();
                this.activeJoiner = undefined;
            }
        };
        this.reject = (error) => {
            if (this.activeJoiner) {
                this.debug("Rejecting joiner promise with error %o.", error);
                this.activeJoiner.reject(error);
                this.activeJoiner = undefined;
            }
        };
        this.id = id;
        this.registrationMessage = registrationMessage;
        this.onMessageHandler = onMessage;
        this.streamExists = streamExists;
        this.unregisterStream = unregisterStream;
        this.socket = socket;
        this.debug = debug;
    }
    get onMessage() {
        return this.onMessageHandler;
    }
    currentActiveMarker() {
        return this.activeMarker;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.send(this.registrationMessage);
        });
    }
    restart(marker) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkMarker(marker);
            if (!this.streamExists(this.id)) {
                throw new error_1.DfuseClientError(`Trying to restart a stream '${this.id}' that is not registered anymore or was never registered`);
            }
            let activeMarker = this.activeMarker;
            if (marker) {
                activeMarker = marker;
            }
            const restartMessage = Object.assign({}, this.registrationMessage);
            if (activeMarker) {
                restartMessage.start_block = activeMarker.atBlockNum;
            }
            yield this.socket.send(restartMessage);
            if (this.onPostRestart) {
                this.onPostRestart();
            }
        });
    }
    join() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeJoiner !== undefined) {
                return this.activeJoiner.promise();
            }
            this.activeJoiner = new promises_1.Deferred();
            return this.activeJoiner.promise();
        });
    }
    mark(marker) {
        this.activeMarker = this.checkMarker(marker);
    }
    close(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.unregisterStream(this.id)
                .then(() => {
                if (options.error) {
                    this.reject(options.error);
                }
                else {
                    this.resolve();
                }
            })
                // FIXME: We should probably return a MultiError of some kind to report both error if `options.error` exists
                .catch(this.reject));
        });
    }
    checkMarker(marker) {
        if (!marker) {
            return undefined;
        }
        if (!marker.atBlockNum || marker.atBlockNum < 0) {
            throw new error_1.DfuseClientError("Only non-zero & positive `atBlockNum` markers are accepted for this operation");
        }
        return marker;
    }
}
//# sourceMappingURL=stream-client.js.map