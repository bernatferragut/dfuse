"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const socket_1 = require("./socket");
const promises_1 = require("../helpers/promises");
const error_1 = require("../types/error");
const time_1 = require("../helpers/time");
exports.DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS = 2500; // 2.5s
/**
 * Create the default [[StreamClient]] concrete implementation.
 *
 * @param wsUrl The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter. Passed as
 * is to created [[Socket]] interface through the [[createSocket]] factory method. This parameter has no effect
 * if [[StreamClientOptions.socket]] options is used.
 * @param options The set of options used to construct the default [[StreamClient]] instance. See
 * [[StreamClientOptions]] for documentation of the options and default values for each of them.
 */
function createGraphqlStreamClient(wsUrl, options = {}) {
    return new DefaultGrahqlStreamClient(options.socket ||
        socket_1.createSocket(wsUrl, Object.assign({ id: "graphql", webSocketProtocols: "graphql-ws" }, options.socketOptions)), options.autoRestartStreamsOnReconnect === undefined
        ? true
        : options.autoRestartStreamsOnReconnect, options.autoRestartStreamsOnError === undefined ? true : options.autoRestartStreamsOnError, options.restartOnErrorDelayInMs === undefined
        ? exports.DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS
        : options.restartOnErrorDelayInMs, options.autoDisconnectSocket === undefined ? true : options.autoDisconnectSocket);
}
exports.createGraphqlStreamClient = createGraphqlStreamClient;
class DefaultGrahqlStreamClient {
    constructor(socket, autoRestartStreamsOnReconnect, autoRestartStreamsOnError, restartOnErrorDelayInMs, autoDisconnectSocket) {
        this.debug = debug_1.default("dfuse:graphql-stream");
        this.debugTrace = debug_1.default("dfuse-trace:graphql-stream");
        this.streams = {};
        this.handleMessage = (rawMessage) => __awaiter(this, void 0, void 0, function* () {
            const message = rawMessage;
            if (message.type === "ka") {
                this.debug("Discarding 'ka' (Keep Alive) message from reaching the underlying stream(s).");
                return;
            }
            if (message.type === "connection_ack" || message.type === "connection_error") {
                this.connectionEstablisher.onMessage(message);
                return;
            }
            let debug = this.debug;
            if (message.type === "data") {
                debug = this.debugTrace;
            }
            debug("Routing socket message of type '%s' with id '%s' to appropriate stream", message.type, message.id);
            const stream = this.streams[message.id || ""];
            if (stream === undefined) {
                this.debug("No stream currently registered able to handle message with 'id: %s'", message.id);
                return;
            }
            if (message.type === "data") {
                if (message.payload.errors) {
                    stream.onMessage({ type: "error", errors: message.payload.errors, terminal: false }, stream);
                }
                else {
                    stream.onMessage({ type: "data", data: message.payload.data }, stream);
                }
                // Let's not continue for a data message
                return;
            }
            const onStreamCloseError = (error) => {
                // FIXME: We shall pass this error somewhere, to some kind of notifier or event
                //        emitter but there is no such stuff right now.
                this.debug("Closing the stream [%s] (in response of GraphQL '%s' message) failed %O.", stream.id, message.type, error);
            };
            if (message.type === "error") {
                stream.onMessage({ type: "error", errors: [message.payload], terminal: true }, stream);
                if (this.autoRestartStreamsOnError) {
                    this.debug("Stream [%s] received error message and auto restart on error set, waiting [%d ms] before restarting", stream.id, this.restartOnErrorDelayInMs);
                    yield time_1.waitFor(this.restartOnErrorDelayInMs);
                    yield stream.restart().catch((error) => {
                        // Can only happen if the socket does not auto-reconnect and connection lost, in which, stream is screwed anyway
                        stream.close({ error }).catch(onStreamCloseError);
                    });
                    return;
                }
                stream.isActive = false;
            }
            if (message.type === "complete") {
                stream.onMessage({ type: "complete" }, stream);
                stream.isActive = false;
            }
            this.debug("About to close stream [%s] due to GraphQL '%s' message.", stream.id, message.type);
            const closeError = message.type === "error" ? message.payload : undefined;
            stream.close({ error: closeError }).catch(onStreamCloseError);
        });
        this.handleReconnection = () => {
            this.debug("Handling re-connection notification from socket.");
            if (this.autoRestartStreamsOnReconnect === false) {
                return;
            }
            this.connectionEstablisher
                .establish(this.apiToken, this.socket)
                .then(() => {
                return Promise.all(Object.keys(this.streams).map((id) => this.streams[id].restart()));
            })
                .catch((error) => __awaiter(this, void 0, void 0, function* () {
                const finalizer = () => {
                    // FIXME: We shall pass this error somewhere, to some kind of notifier or event
                    //        emitter but there is no such stuff right now.
                    this.debug("The re-connection failed to re-establish the GraphQL connection %O", error);
                };
                return Promise.all(Object.keys(this.streams).map((id) => this.streams[id].close({ error })))
                    .then(finalizer)
                    .catch(finalizer);
            }));
        };
        this.socket = socket;
        this.autoRestartStreamsOnReconnect = autoRestartStreamsOnReconnect;
        this.autoRestartStreamsOnError = autoRestartStreamsOnError;
        this.restartOnErrorDelayInMs = restartOnErrorDelayInMs;
        this.autoDisconnectSocket = autoDisconnectSocket;
        this.connectionEstablisher = new GraphqlConnectionEstablisher(this.debug);
    }
    release() {
        this.debug("Terminating connection & releasing default GraphQL stream client");
        this.socket.disconnect().catch((error) => {
            this.debug("An error occurred while disconnecting from socket while releasing instance", error);
        });
    }
    setApiToken(apiToken) {
        this.apiToken = apiToken;
    }
    registerStream(id, document, variables, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.socket.isConnected) {
                this.debug("Socket is not connected, connecting socket first.");
                yield this.socket.connect(this.handleMessage, { onReconnect: this.handleReconnection });
                yield this.connectionEstablisher.establish(this.apiToken, this.socket);
            }
            if (this.streams[id] !== undefined) {
                throw new error_1.DfuseClientError(`A stream with id '${id}' is already registered, cannot register another one with the same id`);
            }
            this.debug("Registering stream [%s]", id);
            const streamExists = (streamId) => this.streams[streamId] !== undefined;
            const unregisterStream = (streamId) => this.unregisterStream(streamId);
            const stream = new DefaultGraphqlStream(id, document, variables, onMessage, streamExists, unregisterStream, this.socket, this.debug);
            // Let's first register stream to ensure that if messages arrives before we got back
            // execution flow after `send` call, the listener is already present to handle message
            this.streams[id] = stream;
            try {
                yield stream.start();
            }
            catch (error) {
                delete this.streams[id];
                throw new error_1.DfuseClientError(`Unable to correctly register stream '${id}'`, error);
            }
            this.debug("Stream [%s] registered with remote endpoint.", id);
            return stream;
        });
    }
    unregisterStream(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = this.streams[id];
            if (stream === undefined) {
                this.debug("Stream [%s] is already unregistered, nothing to do.", id);
                return;
            }
            this.debug("Unregistering stream [%s].", id);
            delete this.streams[id];
            try {
                if (stream.isActive && this.socket.isConnected) {
                    yield this.socket.send({ id, type: "stop" });
                }
                if (Object.keys(this.streams).length <= 0 && this.autoDisconnectSocket) {
                    this.debug("No more stream present and auto disconnect sets to true, terminating connection & disconnecting socket.");
                    if (this.socket.isConnected) {
                        yield this.socket.disconnect();
                    }
                }
                stream.onUnregister();
            }
            catch (error) {
                stream.onUnregister(error);
                throw error;
            }
        });
    }
}
class DefaultGraphqlStream {
    constructor(id, registrationDocument, registrationVariables, onMessage, streamExists, unregisterStream, socket, debug) {
        this.resolve = () => {
            if (this.activeJoiner) {
                this.debug("Resolving joiner promise for stream [%s].", this.id);
                this.activeJoiner.resolve();
            }
        };
        this.reject = (error) => {
            if (this.activeJoiner) {
                this.debug("Rejecting joiner promise for stream [%s] with error %o.", this.id, error);
                this.activeJoiner.reject(error);
            }
        };
        this.id = id;
        this.active = false;
        this.registrationDocument = registrationDocument;
        this.registrationVariables = registrationVariables;
        this.onMessageHandler = onMessage;
        this.streamExists = streamExists;
        this.unregisterStream = unregisterStream;
        this.socket = socket;
        this.debug = debug;
    }
    get isActive() {
        return this.active;
    }
    set isActive(value) {
        this.active = value;
    }
    get onMessage() {
        return this.onMessageHandler;
    }
    currentActiveMarker() {
        return this.activeMarker;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield this.createStartMessage();
            if (message.payload.variables !== undefined) {
                message.payload.variables = Object.assign({ cursor: "" }, message.payload.variables);
            }
            return this.socket.send(message).then(() => {
                this.active = true;
            });
        });
    }
    restart(marker) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to restart stream [%s]", this.id);
            this.checkMarker(marker);
            if (!this.streamExists(this.id)) {
                throw new error_1.DfuseClientError(`Trying to restart a stream '${this.id}' that is not registered anymore or was never registered`);
            }
            let activeMarker = this.activeMarker;
            if (marker) {
                activeMarker = marker;
            }
            const message = yield this.createStartMessage();
            if (activeMarker) {
                message.payload.variables = Object.assign(Object.assign({}, (message.payload.variables || {})), { 
                    // @ts-ignore The `cursor` field is the only possibility here, it's just TypeScript can't discriminate it
                    cursor: activeMarker.cursor });
            }
            yield this.socket.send(message).then(() => {
                this.active = true;
            });
            if (this.onPostRestart) {
                this.onPostRestart();
            }
        });
    }
    createStartMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            let resolvedVariables = this.registrationVariables;
            if (typeof resolvedVariables === "function") {
                // We use `as any` here because the docs builder which uses TypeScript 3.2.4 chokes on this line due to hard typing.
                // At some point, the `typedoc` will be updated and the error should resolves itself. Simply remove the cast and
                // regenerate the docs `yarn build:docs` to test if it's fixed or not.
                resolvedVariables = yield resolvedVariables();
            }
            return {
                id: this.id,
                type: "start",
                payload: {
                    query: this.registrationDocument,
                    variables: Object.assign({ cursor: "" }, (resolvedVariables || {}))
                }
            };
        });
    }
    join() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeJoiner !== undefined) {
                return this.activeJoiner.promise();
            }
            this.activeJoiner = new promises_1.Deferred();
            return this.activeJoiner.promise();
        });
    }
    mark(marker) {
        this.activeMarker = this.checkMarker(marker);
    }
    close(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.closeError = options.error;
            return yield this.unregisterStream(this.id);
        });
    }
    checkMarker(marker) {
        if (!marker) {
            return undefined;
        }
        if (!marker.cursor) {
            throw new error_1.DfuseClientError("Only non-empty `cursor` markers are accepted for this operation");
        }
        return marker;
    }
    // Public only for the stream client to be able to call us directly. Not best practice but since
    // the client and his streams are tighly coupled, cohesion makes sense here. Will never be seen
    // by a consumer anyway and this method is not part of any backward compatibility policy.
    onUnregister(unregisterError) {
        // FIXME: We should probably return a MultiError of some kind to report both of
        //        `unregisterError` and `this.closeError` if they are both set.
        if (unregisterError) {
            this.reject(unregisterError);
        }
        else if (this.closeError) {
            this.reject(this.closeError);
        }
        else {
            this.resolve();
        }
    }
}
class GraphqlConnectionEstablisher {
    constructor(debug) {
        this.debug = debug;
    }
    establish(apiToken, socket) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeDeferred !== undefined) {
                return this.activeDeferred.promise();
            }
            this.activeDeferred = new promises_1.Deferred();
            this.activeSocket = socket;
            this.debug("Initiating graphql stream connection");
            socket.send({
                type: "connection_init",
                payload: {
                    Authorization: apiToken
                }
            });
            return this.activeDeferred.promise();
        });
    }
    onMessage(message) {
        if (this.activeDeferred === undefined) {
            return;
        }
        if (message.type === "connection_ack") {
            this.debug("Received connection_ack message, resolving active promise");
            this.resolve();
            return;
        }
        if (message.type === "connection_error") {
            this.debug("Received connection_error message %O, rejecting active promise", message.payload);
            this.reject(message.payload);
            return;
        }
        this.debug("Received an unknown message while waiting for graphql connection to establish, something is fishy %O", message);
    }
    resolve() {
        if (this.activeDeferred === undefined) {
            return;
        }
        this.debug("Resolving connection establisher deferred promise.");
        this.activeDeferred.resolve();
        this.activeDeferred = undefined;
    }
    reject(error) {
        const complete = () => {
            if (this.activeDeferred !== undefined) {
                this.debug("Rejecting connection establisher deferred promise.");
                this.activeDeferred.reject(error);
                this.activeDeferred = undefined;
            }
        };
        if (this.activeSocket && this.activeSocket.isConnected) {
            this.activeSocket
                .disconnect()
                .then(complete)
                .catch(complete);
        }
        else {
            complete();
        }
    }
}
//# sourceMappingURL=graphql-stream-client.js.map