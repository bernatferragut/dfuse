"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("../types/error");
// These modules will be replaced by empty modules for an UMD build (Browser), check rollup.config.js `umdBuild`
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
/**
 * Represents an in-memory token storage concrete implementation of
 * a . This simply keep the token in variable and serves
 * it from there.
 *
 * It is **never** persisted and will be reset upon restart of the Browser tab
 * or process, leading to a new token being issued.
 *
 * You should try hard to use a persistent solution so that you re-use the
 * same token as long as it's valid.
 */
class InMemoryApiTokenStore {
    release() {
        return;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiTokenInfo;
        });
    }
    set(apiTokenInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.apiTokenInfo = apiTokenInfo;
        });
    }
}
exports.InMemoryApiTokenStore = InMemoryApiTokenStore;
/**
 * Represents an [[ApiTokenStore]] that saves the token as a JSON string
 * in the `localStorage` of the Browser.
 *
 * Trying to use this class when `window.localStorage` is not a function
 * (like in a Node.js environment) will throw an error at construction
 * time. Use another implementation. If this error is thrown nonetheless
 * in your Browser, local storage is probably not supported there.
 *
 * It is persisted in the local storage of the Browser it will be picked up
 * upon restart of the Browser tab.
 */
class LocalStorageApiTokenStore {
    constructor(key) {
        this.key = key;
        if (typeof localStorage !== "object") {
            const messages = [
                "This environment does not contain a valid `localStorage` object in the global scope to use.",
                "",
                "You are most likely in a Node.js environment where a global `localStorage` is not available by default.",
                "This API token store concrete impelementation is not usable in your environment. You should be",
                "providing a different implementation of ApiTokenInfo.",
                "",
                "If this error occurred when you did not provide yourself the instance, it means our auto-detection",
                "mechanism incorrectly thought it could use `LocalStorageApiTokenStore` instance while it should",
                "have not. Please report a bug about this issue so we can fix it.",
                "",
                "If you provided the instance yourself, you should read our documentation to better",
                "understand what you should provide here.",
                "",
                "See https://github.com/dfuse-io/client-js"
            ];
            throw new error_1.DfuseClientError(messages.join("\n"));
        }
    }
    release() {
        return;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiTokenInfo !== undefined) {
                return this.apiTokenInfo;
            }
            const raw = localStorage.getItem(this.key);
            if (raw == null) {
                return undefined;
            }
            this.apiTokenInfo = JSON.parse(raw);
            return this.apiTokenInfo;
        });
    }
    set(apiTokenInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.apiTokenInfo = apiTokenInfo;
            localStorage.setItem(this.key, JSON.stringify(apiTokenInfo));
        });
    }
}
exports.LocalStorageApiTokenStore = LocalStorageApiTokenStore;
/**
 * Represents an [[ApiTokenStore]] implementation that will save
 * as a JSON string in plain text in the given file.
 *
 * The directory structure is created when it does not exists.
 *
 * **Note** This cannot be used in a browser environment
 */
class FileApiTokenStore {
    constructor(filePath) {
        this.filePath = filePath;
    }
    release() {
        return;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiTokenInfo !== undefined) {
                return this.apiTokenInfo;
            }
            const data = yield readData(this.filePath);
            if (data === undefined) {
                return undefined;
            }
            this.apiTokenInfo = JSON.parse(data);
            return this.apiTokenInfo;
        });
    }
    set(apiTokenInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.apiTokenInfo = apiTokenInfo;
            yield writeData(this.filePath, JSON.stringify(apiTokenInfo));
        });
    }
}
exports.FileApiTokenStore = FileApiTokenStore;
/**
 * Represents an [[ApiTokenStore]] implementation that will save
 * as a JSON string in a file located at
 * `~/.dfuse/<sha256-api-key>/token.json`.
 *
 * The directory structure is created when it does not exists.
 *
 * **Note** This cannot be used in a browser environment.
 */
class OnDiskApiTokenStore extends FileApiTokenStore {
    constructor(apiKey) {
        const homeDirectory = os_1.default.homedir();
        const sha256sum = crypto_1.default.createHash("sha256");
        super(`${homeDirectory}/.dfuse/${sha256sum.update(apiKey).digest("hex")}/token.json`);
    }
}
exports.OnDiskApiTokenStore = OnDiskApiTokenStore;
function readData(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (!fs_1.default.existsSync(filePath)) {
                resolve(undefined);
                return;
            }
            fs_1.default.readFile(filePath, (error, data) => {
                error ? reject(error) : resolve(data);
            });
        });
    });
}
function writeData(filePath, data) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            try {
                mkdirpSync(path_1.default.dirname(filePath));
            }
            catch (error) {
                reject(error);
                return;
            }
            fs_1.default.writeFile(filePath, data, (error) => {
                error ? reject(error) : resolve();
            });
        });
    });
}
function mkdirpSync(directory) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!path_1.default.isAbsolute(directory)) {
            return;
        }
        const parent = path_1.default.join(directory, "..");
        if (parent !== path_1.default.join("/") && !fs_1.default.existsSync(parent)) {
            mkdirpSync(parent);
        }
        if (!fs_1.default.existsSync(directory)) {
            fs_1.default.mkdirSync(directory);
        }
    });
}
//# sourceMappingURL=api-token-store.js.map