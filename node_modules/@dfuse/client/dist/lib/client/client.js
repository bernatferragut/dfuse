"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const outbound_1 = require("../message/outbound");
const api_token_manager_1 = require("./api-token-manager");
const http_client_1 = require("./http-client");
const http_client_2 = require("../types/http-client");
const error_1 = require("../types/error");
const stream_client_1 = require("./stream-client");
const graphql_stream_client_1 = require("./graphql-stream-client");
const api_token_store_1 = require("./api-token-store");
const refresh_scheduler_1 = require("./refresh-scheduler");
const MAX_UINT32_INTEGER = 2147483647;
// Small module wide variable incremented each time a client instance is created
let clientInstanceId = 0;
/**
 * The main entry point of the library, use it to create the standard [[DfuseClient]]
 * instance.
 *
 * Only the `apiKey` and `network` parameters are mandatory, all others have sane
 * default values based on your execution environment (be it a Browser or Node.js).
 *
 * This will create the default
 *
 * @param options The options that can be passed to customize [[DfuseClient]] instance,
 * refer to the [[DfuseClientOptions]] for further details.
 *
 * @kind Factories
 */
function createDfuseClient(options) {
    checkApiKey(options.apiKey);
    const endpoint = networkToEndpoint(options.network);
    const secureEndpoint = options.secure === undefined ? true : options.secure;
    const authUrl = options.authUrl || "https://auth.dfuse.io";
    const restUrl = secureEndpoint ? `https://${endpoint}` : `http://${endpoint}`;
    const websocketUrl = secureEndpoint ? `wss://${endpoint}` : `ws://${endpoint}`;
    const endpoints = {
        authUrl,
        graphqlQueryUrl: `${restUrl}/graphql`,
        graphqlStreamUrl: `${websocketUrl}/graphql`,
        restUrl,
        websocketUrl
    };
    const httpClient = options.httpClient || http_client_1.createHttpClient(authUrl, restUrl, options.httpClientOptions);
    const streamClient = options.streamClient ||
        stream_client_1.createStreamClient(websocketUrl + "/v1/stream", options.streamClientOptions);
    const graphqlStreamClient = options.graphqlStreamClient ||
        graphql_stream_client_1.createGraphqlStreamClient(endpoints.graphqlStreamUrl, options.graphqlStreamClientOptions);
    const apiTokenStore = options.apiTokenStore || inferApiTokenStore(options.apiKey);
    const refreshScheduler = options.refreshScheduler || refresh_scheduler_1.createRefreshScheduler();
    const requestIdGenerator = options.requestIdGenerator || randomReqId;
    return new DefaultClient(clientInstanceId++, options.apiKey, endpoints, httpClient, streamClient, graphqlStreamClient, apiTokenStore, refreshScheduler, requestIdGenerator);
}
exports.createDfuseClient = createDfuseClient;
// Even though higher the type say it cannot be empty, this is usually provided
// by the user and as such, as assume it could be undefined.
function checkApiKey(apiKey) {
    if (apiKey == null) {
        const messages = [
            "The client must be configured with an API key via the ",
            "`apiKey` config options.",
            "",
            "Received nothing."
        ];
        throw new error_1.DfuseError(messages.join("\n"));
    }
    if (!apiKey.match(/^(mobile|server|web)_[0-9a-f]{2,}/i)) {
        const messages = [
            "The provided API key is not in the right format, expecting it",
            "to start with either `mobile_`, `server_` or `web_` followed",
            "by a series of hexadecimal character (i.e.) `web_0123456789abcdef`)",
            ""
        ];
        // Assume it's an API token if looks (roughly) like a JWT token
        if (apiKey.split(".").length === 3) {
            messages.push("It seems your providing directly a API token (JWT) instead", "of an API key and are using your previous authentication protocol.", "Please refer to http://docs.dfuse.io/#authentication for", "all the details about API key and how to generate an API token", "from it.", "", "And you can visit https://app.dfuse.io to obtain your free API key", "");
        }
        messages.push(`Input received: ${apiKey}`);
        throw new error_1.DfuseError(messages.join("\n"));
    }
}
function inferApiTokenStore(apiKey) {
    const debug = debug_1.default("dfuse:client");
    debug("Inferring API token store default concrete implementation to use");
    if (typeof window !== "undefined" && window.localStorage != null) {
        debug('Using `LocalStorageApiTokenStore` as we assumed a Browser environment (`typeof window.localStorage !== "undefined"`).');
        return new api_token_store_1.LocalStorageApiTokenStore("dfuse:token");
    }
    // Just in the sake that `window.localStorage` is not supported for whatever, fall
    // back to Node.js default only if we are really in a Node.js like environment.
    if (typeof window === "undefined") {
        debug('Using `OnDiskLocalStorageApiTokenStore` as we assumed a Node.js enviroment (`typeof window === "undefined"`).');
        return new api_token_store_1.OnDiskApiTokenStore(apiKey);
    }
    debug("Falling back default `InMemoryApiTokenStore` concrete implementation");
    return new api_token_store_1.InMemoryApiTokenStore();
}
function networkToEndpoint(network) {
    if (network === "mainnet" ||
        network === "jungle" ||
        network === "kylin" ||
        network === "worbli") {
        return `${network}.eos.dfuse.io`;
    }
    // Network is assumed to be an hostname to reach the dfuse service
    return network;
}
exports.networkToEndpoint = networkToEndpoint;
/**
 * The standard implementation of a [[DfuseClient]].
 *
 * The [[DefaultClient]] role is to perform the API key management
 * functionalities of the client. It retrieves an API token using the
 * API key and ensures it stays valid throughout the lifecycle of the
 * client, refreshing the token when necessary.
 *
 * It also responsible of keep and up-to-date list of streams and managing
 * the re-connection to those stream when the websocket disconnects.
 *
 * It is supported to override the client to provide some other
 * methods on it (other EOS endpoints).
 */
class DefaultClient {
    constructor(id, apiKey, endpoints, httpClient, streamClient, graphqlStreamClient, apiTokenStore, refreshScheduler, requestIdGenerator) {
        this.debug = debug_1.default("dfuse:client");
        this.withDefaultOptions = (options) => {
            return Object.assign({ req_id: `${this.requestIdGenerator()}-${this.id}` }, options);
        };
        this.onTokenRefresh = (apiToken) => {
            // Ensure we update the API token to have it at its latest value
            this.streamClient.setApiToken(apiToken);
            this.graphqlStreamClient.setApiToken(apiToken);
        };
        this.id = id;
        this.apiKey = apiKey;
        this.endpoints = endpoints;
        this.httpClient = httpClient;
        this.streamClient = streamClient;
        this.graphqlStreamClient = graphqlStreamClient;
        this.requestIdGenerator = requestIdGenerator;
        if (this.endpoints.authUrl.startsWith("null://")) {
            this.apiTokenManager = api_token_manager_1.createNoopApiTokenManager("a.b.c");
        }
        else {
            this.apiTokenManager = api_token_manager_1.createApiTokenManager(() => this.authIssue(this.apiKey), this.onTokenRefresh, 0.95, apiTokenStore, refreshScheduler);
        }
    }
    release() {
        this.debug("Releasing default dfuse client");
        this.httpClient.release();
        this.streamClient.release();
        this.graphqlStreamClient.release();
        this.apiTokenManager.release();
    }
    //
    /// GraphQL API
    //
    // The return type has `Promise<GraphqlResponse<T> | Stream | any>`. The `any` sadly is an
    // artefact to please the compiler. Without it, the compiler thinks the resulting type is
    // not a proper implementation of `DfuseClient.graphql` which has two signatures, both of them
    // being of a different return type.
    graphql(document, onMessage, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof onMessage !== "function" && onMessage) {
                options = onMessage;
            }
            if (options.operationType && !isValidDocumentType(options.operationType)) {
                throw new error_1.DfuseError(`The 'options.operationType' value '${options.operationType}' is invalid, it must be either 'query', 'mutation' or 'subscription').`);
            }
            // If an `onMessage` options is provided, always use the WebSocket connection
            const onMessageProvided = typeof onMessage === "function" && onMessage;
            if (onMessageProvided) {
                return this.withApiToken((apiTokenInfo) => {
                    this.graphqlStreamClient.setApiToken(apiTokenInfo.token);
                    return this.graphqlStreamClient.registerStream(`${this.requestIdGenerator()}-${this.id}`, 
                    // FIXME: Turn the document if a GraphQL document into a proper document string
                    document, options.variables, onMessage);
                });
            }
            const operationType = this.inferOperationType(document, options.operationType);
            if (!operationType && !onMessageProvided) {
                const messages = [
                    "We were not able to infer the GraphQL operation type you are trying to perform from",
                    "the document and options you provided. Without the document's operation type, we are",
                    "unable to determine the transport layer to use to execute your operation, either HTTP",
                    "or WebSocket transport.",
                    "",
                    "If you passed a document as a plain 'string' value, please use the `options.operationType`",
                    "option to provide the operation type to perform. You can also use the 'gql' string literal",
                    "processor to turn your string into a rich Document, on which inference always work.",
                    "",
                    "If you already provided the document a rich Document format via the 'gql` ...`' call, then it's",
                    "probably a bug in this library. You can provide the `options.operationType` option to workaround",
                    "the problem and report the bug to us with the document string used.",
                    "",
                    "Valid `options.operationType` values are either 'query', 'mutation' or 'subscription'.",
                    "",
                    "You can also force usage of WebSocket transport by providing the `options.onMessage` which",
                    "forces the usage of the WebSocket transport."
                ];
                throw new error_1.DfuseError(messages.join("\n"));
            }
            if (operationType === "subscription" && !onMessageProvided) {
                const messages = [
                    "The `options.onMessage` parameter is required for 'subscription' document.",
                    "If your document is not a 'subscription' type, this is probably a bug with the library.",
                    "You can provide the `options.operationType` option to workaroundthe problem and report",
                    "the bug to us with the document string used."
                ];
                throw new error_1.DfuseError(messages.join("\n"));
            }
            // FIXME: Turn the document into a proper document string if a GraphQL document
            return yield this.apiRequest("/graphql", "POST", {}, { query: document, variables: options.variables });
        });
    }
    //
    /// WebSocket API
    //
    streamActionTraces(data, onMessage, options = {}) {
        return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => messageCreator(outbound_1.OutboundMessageType.GET_ACTION_TRACES, data, withDefaultOptions(Object.assign({ listen: true }, options))));
    }
    streamTableRows(data, onMessage, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => messageCreator(outbound_1.OutboundMessageType.GET_TABLE_ROWS, Object.assign({ json: true }, data), withDefaultOptions(Object.assign({ listen: true }, options))));
        });
    }
    streamTransaction(data, onMessage, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => messageCreator(outbound_1.OutboundMessageType.GET_TRANSACTION_LIFECYCLE, data, withDefaultOptions(Object.assign({ listen: true, fetch: true }, options))));
        });
    }
    streamHeadInfo(onMessage, options = {}) {
        return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => {
            return messageCreator(outbound_1.OutboundMessageType.GET_HEAD_INFO, {}, withDefaultOptions(Object.assign({ listen: true }, options)));
        });
    }
    websocketStream(onMessage, initMessageFactory) {
        const message = initMessageFactory(outbound_1.createOutboundMessage, this.withDefaultOptions);
        return this.registerStream(message, onMessage);
    }
    //
    /// HTTP API
    //
    authIssue(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.httpClient.authRequest(http_client_2.V1_AUTH_ISSUE, "POST", undefined, {
                api_key: apiKey
            });
        });
    }
    fetchBlockIdByTime(time, comparator) {
        return __awaiter(this, void 0, void 0, function* () {
            let timeString = time;
            if (time instanceof Date) {
                timeString = time.toISOString();
            }
            return this.apiRequest(http_client_2.V0_FETCH_BLOCK_ID_BY_TIME, "GET", {
                time: timeString,
                comparator
            });
        });
    }
    fetchTransaction(id) {
        // TODO: Should we properly URL encode the transaction id?
        return this.apiRequest(http_client_2.V0_FETCH_TRANSACTION.replace(":id", id), "GET");
    }
    searchTransactions(q, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_SEARCH_TRANSACTIONS, "GET", {
                q,
                start_block: options.startBlock,
                sort: options.sort,
                block_count: options.blockCount === undefined ? MAX_UINT32_INTEGER : options.blockCount,
                limit: options.limit,
                cursor: options.cursor,
                with_reversible: options.withReversible
            });
        });
    }
    stateAbi(account, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_ABI, "GET", {
                account,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json
            });
        });
    }
    stateAbiBinToJson(account, table, hexRows, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_ABI_BIN_TO_JSON, "POST", undefined, {
                account,
                table,
                hex_rows: hexRows,
                block_num: options.blockNum
            });
        });
    }
    stateKeyAccounts(publicKey, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_KEY_ACCOUNTS, "GET", {
                public_key: publicKey,
                block_num: options.blockNum
            });
        });
    }
    statePermissionLinks(account, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_PERMISSION_LINKS, "GET", {
                account,
                block_num: options.blockNum
            });
        });
    }
    stateTableScopes(account, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_TABLE_SCOPES, "GET", {
                account,
                table,
                block_num: options.blockNum
            });
        });
    }
    stateTable(account, scope, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_TABLE, "GET", {
                account,
                scope,
                table,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            });
        });
    }
    stateTableRow(account, scope, table, primaryKey, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_TABLE_ROW, "GET", {
                account,
                scope,
                table,
                primary_key: primaryKey,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            });
        });
    }
    stateTablesForAccounts(accounts, scope, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_TABLES_ACCOUNTS, "POST", undefined, {
                accounts: accounts.join("|"),
                scope,
                table,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            }, {
                "Content-Type": "application/x-www-form-urlencoded"
            });
        });
    }
    stateTablesForScopes(account, scopes, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(http_client_2.V0_STATE_TABLES_SCOPES, "POST", undefined, {
                account,
                scopes: scopes.join("|"),
                table,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            }, {
                "Content-Type": "application/x-www-form-urlencoded"
            });
        });
    }
    apiRequest(path, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.withApiToken((apiTokenInfo) => {
                return this.httpClient.apiRequest(apiTokenInfo.token, path, method, params, body, headers);
            });
        });
    }
    getTokenInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiTokenManager.getTokenInfo();
        });
    }
    registerStream(message, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.withApiToken((apiTokenInfo) => {
                this.streamClient.setApiToken(apiTokenInfo.token);
                return this.streamClient.registerStream(message, onMessage);
            });
        });
    }
    withApiToken(worker) {
        return __awaiter(this, void 0, void 0, function* () {
            let apiTokenInfo;
            try {
                this.debug("Retrieving latest API token via token manager");
                apiTokenInfo = yield this.apiTokenManager.getTokenInfo();
            }
            catch (error) {
                throw new error_1.DfuseClientError("Unable to obtain the API token", error);
            }
            return yield worker(apiTokenInfo);
        });
    }
    inferOperationType(document, predefinedOperationType) {
        this.debug("Trying to infer operation type based on document and predefined operation type, predefined operation type '%s' and document %o", predefinedOperationType, document);
        if (predefinedOperationType) {
            this.debug("Predefined type '%s' provided, using it straight away.", predefinedOperationType);
            return predefinedOperationType;
        }
        if (typeof document === "string") {
            this.debug("Document is a plain string type, performing a poor-man Regex extraction.");
            const matches = document.match(/^\s*(query|mutation|subscription)?\s*([_A-Za-z][_0-9A-Za-z]*\s*)?(\([^\)]*\)\s*)?{/);
            if (matches == null) {
                this.debug("Document string did not match our Regex, aborting inference.");
                return undefined;
            }
            if (matches && matches[1]) {
                this.debug("Document string Regex matches have operation type '%s', using it.", matches[1]);
                return matches[1];
            }
            this.debug("Document string Regex matches but operation type was not present, using 'query'.");
            return "query";
        }
        // FIXME: Make the initial AST walking and work our way through!
        return undefined;
    }
}
exports.DefaultClient = DefaultClient;
function isValidDocumentType(type) {
    if (!type) {
        return false;
    }
    return type === "subscription" || type === "query" || type === "mutation";
}
function randomReqId() {
    return `dc-${Math.random()
        .toString(16)
        .substr(2)}`;
}
//# sourceMappingURL=client.js.map