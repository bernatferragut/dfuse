"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
exports.DEFAULT_DELAY_BUFFER_PERCENT = 0.95;
/**
 * Create the standard [[ApiTokenManager]] interface that will manage all the lifecycle
 * of a token.
 *
 * @param fetchTokenInfo The async function that should be used to retrieve a fresh token.
 * @param onTokenRefresh The function to call when a token has been refreshed.
 * @param delayBuffer The percentage of time to use to schedule the next token refresh
 *                    (i.e. with a value of `0.9` and a token valid for 1000ms from now,
 *                    the next refresh would be scheduled to happen at `now + (0.9 * 1000)`)
 * @param apiTokenStore The API token store interface to retrieve token from and to save it back to.
 * @param refreshScheduler The scheduler interface that should be used to schedule upcoming refresh token
 *                         and check if a scheduled one already exist.
 *
 * @kind Factories
 */
function createApiTokenManager(fetchTokenInfo, onTokenRefresh, delayBuffer, apiTokenStore, refreshScheduler) {
    return new DefaultApiTokenManager(fetchTokenInfo, onTokenRefresh, delayBuffer, apiTokenStore, refreshScheduler);
}
exports.createApiTokenManager = createApiTokenManager;
/**
 * Create the Noop [[ApiTokenManager]] interface that will manage all the lifecycle
 * of a token.
 *
 * @param token The hardwired token value (default value -> `a.b.c`)
 *
 * @kind Factories
 */
function createNoopApiTokenManager(token) {
    return new NoopApiTokenManager(token);
}
exports.createNoopApiTokenManager = createNoopApiTokenManager;
/**
 * Check wheter the received [[ApiTokenInfo]] parameter is expired or near its
 * expiration.
 */
function isApiTokenExpired(tokenInfo) {
    const now = Date.now() / 1000;
    return tokenInfo.expires_at <= now;
}
exports.isApiTokenExpired = isApiTokenExpired;
class DefaultApiTokenManager {
    constructor(fetchTokenInfo, onTokenRefresh, delayBuffer, apiTokenStore, refreshScheduler) {
        this.fetchTokenInfo = fetchTokenInfo;
        this.onTokenRefresh = onTokenRefresh;
        this.delayBuffer = delayBuffer;
        this.apiTokenStore = apiTokenStore;
        this.refreshScheduler = refreshScheduler;
        this.debug = debug_1.default("dfuse:token-manager");
    }
    release() {
        this.debug("Releasing default API token manager");
        this.refreshScheduler.release();
        this.apiTokenStore.release();
    }
    getTokenInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenInfo = yield this.apiTokenStore.get();
            if (tokenInfo && !isApiTokenExpired(tokenInfo)) {
                this.maybeScheduleNextRefresh(tokenInfo, { forceRefresh: false });
                this.debug("Returning token found in API token store since it was still valid");
                return Promise.resolve(tokenInfo);
            }
            this.debug("Returning a fresh API token as it was not present in store or expired");
            return yield this.refreshToken();
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenInfo = yield this.internalFetchToken();
            this.debug("Retrieved an API token that is going to expires at %s (%s)", new Date(tokenInfo.expires_at * 1000), tokenInfo.token);
            this.maybeScheduleNextRefresh(tokenInfo, { forceRefresh: true });
            try {
                this.debug("Storing API token into token storage");
                yield this.apiTokenStore.set(tokenInfo);
            }
            catch (error) {
                this.debug("Storing token into storage failed %s (%o)", error, error);
            }
            this.debug("Notifying upstream listener that API token has been refreshed.");
            this.onTokenRefresh(tokenInfo.token);
            return tokenInfo;
        });
    }
    maybeScheduleNextRefresh(tokenInfo, options) {
        if (!options.forceRefresh && this.refreshScheduler.hasScheduledJob()) {
            return;
        }
        const delayInSeconds = this.getRefreshDelayInSeconds(tokenInfo);
        const refreshAt = new Date(Date.now() + delayInSeconds * 1000);
        this.debug("Scheduling next token refresh to occur at %s (in %s seconds)", refreshAt, delayInSeconds);
        this.refreshScheduler.schedule(delayInSeconds, () => this.refreshToken());
    }
    getRefreshDelayInSeconds(tokenInfo) {
        const nowInSeconds = Math.floor(Date.now() / 1000);
        return (tokenInfo.expires_at - nowInSeconds) * this.delayBuffer;
    }
    internalFetchToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fetchTokenPromise !== undefined) {
                return this.fetchTokenPromise;
            }
            this.fetchTokenPromise = new Promise((resolve, reject) => {
                this.fetchTokenInfo()
                    .then((apiTokenInfo) => {
                    this.fetchTokenPromise = undefined;
                    resolve(apiTokenInfo);
                })
                    .catch((error) => {
                    this.fetchTokenPromise = undefined;
                    reject(error);
                });
            });
            return this.fetchTokenPromise;
        });
    }
}
class NoopApiTokenManager {
    constructor(token) {
        this.token = token || "a.b.c";
        this.expiresAt = 0;
        this.debug = debug_1.default("dfuse:token-manager-noop");
    }
    release() {
        this.debug("Releasing default API token manager");
    }
    getTokenInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return { token: this.token, expires_at: this.expiresAt };
        });
    }
}
//# sourceMappingURL=api-token-manager.js.map