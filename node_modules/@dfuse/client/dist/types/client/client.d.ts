import { IDebugger } from "debug";
import { GetActionTracesMessageData, StreamOptions, GetTableRowsMessageData, GetTransactionLifecycleMessageData, OutboundMessage, OutboundMessageFactory } from "../message/outbound";
import { DfuseClient, RequestIdGenerator, DfuseClientEndpoints } from "../types/client";
import { SearchSortType, SearchTransactionsResponse } from "../types/search";
import { AuthTokenResponse, ApiTokenInfo } from "../types/auth-token";
import { StateAbiResponse, StateKeyAccountsResponse, StateAbiToJsonResponse, StateTableScopesResponse, StateKeyType, StateResponse, MultiStateResponse, StatePermissionLinksResponse, StateTableRowResponse } from "../types/state";
import { ApiTokenManager } from "./api-token-manager";
import { HttpClientOptions } from "./http-client";
import { HttpQueryParameters, HttpClient, HttpHeaders } from "../types/http-client";
import { StreamClientOptions } from "./stream-client";
import { GraphqlStreamClientOptions } from "./graphql-stream-client";
import { StreamClient, OnStreamMessage } from "../types/stream-client";
import { ApiTokenStore } from "./api-token-store";
import { RefreshScheduler } from "./refresh-scheduler";
import { Stream } from "../types/stream";
import { TransactionLifecycle } from "../types/transaction";
import { ComparisonOperator, BlockIdByTimeResponse } from "../types/block-id";
import { GraphqlStreamClient, OnGraphqlStreamMessage } from "../types/graphql-stream-client";
import { GraphqlVariables, GraphqlOperationType, GraphqlDocument, GraphqlResponse } from "../types/graphql";
/**
 * All the options that can be pass to dfuse Client factory
 * [[createDfuseClient]].
 */
export interface DfuseClientOptions {
    /**
     * The network to connect to. Can be a plain string in the set
     * `mainnet | jungle | kylin | worbli`. If it's not a string in this
     * set, the value is assumed to be an hostname pointing to the
     * the service, for example, your internal dfuse endpoint.
     *
     * When it's a known network name, the hostname that is used
     * will be the known hostname for this network name.
     *
     * The final urls are constructed using
     * the [[DfuseClientOptions.secure]] option to determine which
     * protocol to use for HTTP (`https` or `http`) and WebSocket
     * (`wss` or `ws`).
     *
     * @see https://docs.dfuse.io/#endpoints
     */
    network: "mainnet" | "jungle" | "kylin" | "worbli" | string;
    /**
     * You dfuse API key to interact with the dfuse API service. You
     * can obtain and manage your API keys at `https://app.dfuse.io`.
     * This is the self-management portal where all information
     * about your account can be found.
     */
    apiKey: string;
    /**
     * Whether to use secure protocols or unsecure ones. This will
     * control final URL constructed using this parameter value and
     * the actual hostname as defined by the [[DfuseClientOptions.network]]
     * value.
     */
    secure?: boolean;
    /**
     * This is the authentication URL that will be reach to issue
     * new API token.
     *
     * @default `https://auth.dfuse.io`
     */
    authUrl?: string;
    /**
     * A function that generates a random request ID. This request ID
     * is used when using the dfuse Stream API when no specific
     * ID is passed at registration time.
     *
     * @default A generator that generates random id of the form `dc-<13-hex-chars>`.
     */
    requestIdGenerator?: RequestIdGenerator;
    /**
     * The [[HttpClient]] instance that [[DfuseClient]] should use to interact
     * with dfuse REST API. When `undefined` (the default), an instance is
     * created using [[createHttpClient]] factory method and used. If
     * [[DfuseClientOptions.httpClientOptions]] is set, it used when creating
     * the default instanve.
     *
     * @default A default [[HttpClient]] instance (via [[createHttpClient]]) using [[DfuseClientOptions.httpClientOptions]].
     */
    httpClient?: HttpClient;
    /**
     * The [[HttpClientOptions]] that should be used when creating the default
     * instance of [[HttpClient]].
     *
     * This parameter has no effect at all if the [[DfuseClientOptions.httpClient]] is
     * provided.
     *
     * @default `{}` See [[HttpClientOptions]] for default values
     */
    httpClientOptions?: HttpClientOptions;
    /**
     * The [[StreamClient]] instance that [[DfuseClient]] should use to interact
     * with dfuse Stream API. When `undefined` (the default), an instance is
     * created using [[createStreamClient]] factory method and used. If
     * [[DfuseClientOptions.streamClientOptions]] is set, it used when creating
     * the default instanve.
     *
     * @default A default [[StreamClient]] instance (via [[createStreamClient]]) using [[DfuseClientOptions.streamClientOptions]].
     */
    streamClient?: StreamClient;
    /**
     * The [[StreamClientOptions]] that should be used when creating the default
     * instance of [[StreamClient]].
     *
     * This parameter has no effect at all if the [[DfuseClientOptions.streamClient]] is
     * provided.
     *
     * @default `{}` See [[StreamClientOptions]] for default values
     */
    streamClientOptions?: StreamClientOptions;
    /**
     * The [[GraphqlStreamClient]] instance that [[DfuseClient]] should use to interact
     * with dfuse GraphQL Subscription API. When `undefined` (the default), an instance is
     * created using [[createGraphqlStreamClient]] factory method and used. If
     * [[DfuseClientOptions.graphqlStreamClientOptions]] is set, it used when creating
     * the default instanve.
     *
     * @default A default [[GraphqlStreamClient]] instance (via [[createGraphqlStreamClient]]) using [[DfuseClientOptions.graphqlStreamClientOptions]].
     */
    graphqlStreamClient?: GraphqlStreamClient;
    /**
     * The [[GraphqlStreamClientOptions]] that should be used when creating the default
     * instance of [[GraphqlStreamClient]].
     *
     * This parameter has no effect at all if the [[DfuseClientOptions.graphqlStreamClient]] is
     * provided.
     *
     * @default `{}` See [[GraphqlStreamClientOptions]] for default values
     */
    graphqlStreamClientOptions?: GraphqlStreamClientOptions;
    /**
     * The API token store instance that should be use by the [[DfuseClient]]
     * to retrieve and store the API token from. It's via this interface the
     * API token is persisted and also retrieved from persistence storage
     * when required.
     *
     * When `undefined` (the default), a [[LocalStorageApiTokenStore]] is
     * used when a Browser environment is detected, a [[OnDiskApiTokenStore]] is
     * used when a Node.js environment is detected and the [[InMemoryApiTokenStore]]
     * is used as a fallback if niether detection worked.
     *
     * @default Inferred based on the environment (Browser [[LocalStorageApiTokenStore]], Node.js [[OnDiskApiTokenStore]], [[InMemoryApiTokenStore]] otherwise).
     */
    apiTokenStore?: ApiTokenStore;
    /**
     * The refresh scheduler instance that should be used to schedule a token
     * refresh. This is more an internal details of the [[DfuseClient]] should
     * most likely `undefined` for most user to pick a default refresh scheduler.
     *
     * @default A default [[RefreshScheduler]] instance (via [[createRefreshScheduler]])
     */
    refreshScheduler?: RefreshScheduler;
}
/**
 * The main entry point of the library, use it to create the standard [[DfuseClient]]
 * instance.
 *
 * Only the `apiKey` and `network` parameters are mandatory, all others have sane
 * default values based on your execution environment (be it a Browser or Node.js).
 *
 * This will create the default
 *
 * @param options The options that can be passed to customize [[DfuseClient]] instance,
 * refer to the [[DfuseClientOptions]] for further details.
 *
 * @kind Factories
 */
export declare function createDfuseClient(options: DfuseClientOptions): DfuseClient;
export declare function networkToEndpoint(network: string): string;
/**
 * The standard implementation of a [[DfuseClient]].
 *
 * The [[DefaultClient]] role is to perform the API key management
 * functionalities of the client. It retrieves an API token using the
 * API key and ensures it stays valid throughout the lifecycle of the
 * client, refreshing the token when necessary.
 *
 * It also responsible of keep and up-to-date list of streams and managing
 * the re-connection to those stream when the websocket disconnects.
 *
 * It is supported to override the client to provide some other
 * methods on it (other EOS endpoints).
 */
export declare class DefaultClient implements DfuseClient {
    readonly endpoints: DfuseClientEndpoints;
    protected id: number;
    protected apiKey: string;
    protected apiTokenManager: ApiTokenManager;
    protected httpClient: HttpClient;
    protected streamClient: StreamClient;
    protected graphqlStreamClient: GraphqlStreamClient;
    protected requestIdGenerator: RequestIdGenerator;
    protected debug: IDebugger;
    constructor(id: number, apiKey: string, endpoints: DfuseClientEndpoints, httpClient: HttpClient, streamClient: StreamClient, graphqlStreamClient: GraphqlStreamClient, apiTokenStore: ApiTokenStore, refreshScheduler: RefreshScheduler, requestIdGenerator: RequestIdGenerator);
    release(): void;
    graphql<T = any>(document: string | GraphqlDocument, onMessage?: OnGraphqlStreamMessage<T> | {
        variables?: GraphqlVariables;
        operationType?: Exclude<GraphqlOperationType, "subscription">;
    }, options?: {
        operationType?: GraphqlOperationType;
        variables?: GraphqlVariables;
    }): Promise<GraphqlResponse<T> | Stream | any>;
    streamActionTraces(data: GetActionTracesMessageData, onMessage: OnStreamMessage, options?: StreamOptions): Promise<Stream>;
    streamTableRows(data: GetTableRowsMessageData, onMessage: OnStreamMessage, options?: StreamOptions): Promise<Stream>;
    streamTransaction(data: GetTransactionLifecycleMessageData, onMessage: OnStreamMessage, options?: StreamOptions): Promise<Stream>;
    streamHeadInfo(onMessage: OnStreamMessage, options?: StreamOptions): Promise<Stream>;
    websocketStream<T>(onMessage: OnStreamMessage, initMessageFactory: OutboundMessageFactory<T>): Promise<Stream>;
    private withDefaultOptions;
    authIssue(apiKey: string): Promise<AuthTokenResponse>;
    fetchBlockIdByTime(time: string | Date, comparator: ComparisonOperator): Promise<BlockIdByTimeResponse>;
    fetchTransaction(id: string): Promise<TransactionLifecycle>;
    searchTransactions(q: string, options?: {
        startBlock?: number;
        sort?: SearchSortType;
        blockCount?: number;
        limit?: number;
        cursor?: string;
        withReversible?: boolean;
    }): Promise<SearchTransactionsResponse>;
    stateAbi(account: string, options?: {
        blockNum?: number;
        json?: boolean;
    }): Promise<StateAbiResponse>;
    stateAbiBinToJson<T = unknown>(account: string, table: string, hexRows: string[], options?: {
        blockNum?: number;
    }): Promise<StateAbiToJsonResponse<T>>;
    stateKeyAccounts(publicKey: string, options?: {
        blockNum?: number;
    }): Promise<StateKeyAccountsResponse>;
    statePermissionLinks(account: string, options?: {
        blockNum?: number;
    }): Promise<StatePermissionLinksResponse>;
    stateTableScopes(account: string, table: string, options?: {
        blockNum?: number;
    }): Promise<StateTableScopesResponse>;
    stateTable<T = unknown>(account: string, scope: string, table: string, options?: {
        blockNum?: number;
        json?: boolean;
        keyType?: StateKeyType;
        withBlockNum?: boolean;
        withAbi?: boolean;
    }): Promise<StateResponse<T>>;
    stateTableRow<T = unknown>(account: string, scope: string, table: string, primaryKey: string, options?: {
        blockNum?: number;
        json?: boolean;
        keyType?: StateKeyType;
        withBlockNum?: boolean;
        withAbi?: boolean;
    }): Promise<StateTableRowResponse<T>>;
    stateTablesForAccounts<T = unknown>(accounts: string[], scope: string, table: string, options?: {
        blockNum?: number;
        json?: boolean;
        keyType?: StateKeyType;
        withBlockNum?: boolean;
        withAbi?: boolean;
    }): Promise<MultiStateResponse<T>>;
    stateTablesForScopes<T = unknown>(account: string, scopes: string[], table: string, options?: {
        blockNum?: number;
        json?: boolean;
        keyType?: StateKeyType;
        withBlockNum?: boolean;
        withAbi?: boolean;
    }): Promise<MultiStateResponse<T>>;
    apiRequest<T>(path: string, method: string, params?: HttpQueryParameters, body?: any, headers?: HttpHeaders): Promise<T>;
    getTokenInfo(): Promise<ApiTokenInfo>;
    protected registerStream(message: OutboundMessage, onMessage: OnStreamMessage): Promise<Stream>;
    private withApiToken;
    private inferOperationType;
    private onTokenRefresh;
}
