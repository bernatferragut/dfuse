{"version":3,"file":"dfuse-client.umd.js","sources":["../node_modules/ms/index.js","../node_modules/debug/src/common.js","../node_modules/debug/src/browser.js","../src/client/api-token-manager.ts","../src/types/error.ts","../src/message/outbound.ts","../src/client/api-token-store.ts","../src/client/http-client.ts","../src/types/http-client.ts","../src/client/socket.ts","../src/message/inbound.ts","../src/helpers/promises.ts","../src/client/stream-client.ts","../src/helpers/time.ts","../src/client/graphql-stream-client.ts","../src/client/refresh-scheduler.ts","../src/client/client.ts","../src/helpers/message.ts","../src/helpers/transaction.ts"],"sourcesContent":["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","import { RefreshScheduler } from \"./refresh-scheduler\"\nimport { ApiTokenStore } from \"./api-token-store\"\nimport debugFactory, { IDebugger } from \"debug\"\nimport { ApiTokenInfo } from \"../types/auth-token\"\n\nexport const DEFAULT_DELAY_BUFFER_PERCENT = 0.95\n\nexport interface ApiTokenManager {\n  release(): void\n  getTokenInfo: () => Promise<ApiTokenInfo>\n}\n\n/**\n * Create the standard [[ApiTokenManager]] interface that will manage all the lifecycle\n * of a token.\n *\n * @param fetchTokenInfo The async function that should be used to retrieve a fresh token.\n * @param onTokenRefresh The function to call when a token has been refreshed.\n * @param delayBuffer The percentage of time to use to schedule the next token refresh\n *                    (i.e. with a value of `0.9` and a token valid for 1000ms from now,\n *                    the next refresh would be scheduled to happen at `now + (0.9 * 1000)`)\n * @param apiTokenStore The API token store interface to retrieve token from and to save it back to.\n * @param refreshScheduler The scheduler interface that should be used to schedule upcoming refresh token\n *                         and check if a scheduled one already exist.\n *\n * @kind Factories\n */\nexport function createApiTokenManager(\n  fetchTokenInfo: () => Promise<ApiTokenInfo>,\n  onTokenRefresh: (apiToken: string) => void,\n  delayBuffer: number,\n  apiTokenStore: ApiTokenStore,\n  refreshScheduler: RefreshScheduler\n): ApiTokenManager {\n  return new DefaultApiTokenManager(\n    fetchTokenInfo,\n    onTokenRefresh,\n    delayBuffer,\n    apiTokenStore,\n    refreshScheduler\n  )\n}\n\n/**\n * Create the Noop [[ApiTokenManager]] interface that will manage all the lifecycle\n * of a token.\n *\n * @param token The hardwired token value (default value -> `a.b.c`)\n *\n * @kind Factories\n */\nexport function createNoopApiTokenManager(token: string): ApiTokenManager {\n  return new NoopApiTokenManager(token)\n}\n\n/**\n * Check wheter the received [[ApiTokenInfo]] parameter is expired or near its\n * expiration.\n */\nexport function isApiTokenExpired(tokenInfo: ApiTokenInfo): boolean {\n  const now = Date.now() / 1000\n  return tokenInfo.expires_at <= now\n}\n\nclass DefaultApiTokenManager implements ApiTokenManager {\n  private fetchTokenInfo: () => Promise<ApiTokenInfo>\n  private onTokenRefresh: (apiToken: string) => void\n  private delayBuffer: number\n  private apiTokenStore: ApiTokenStore\n  private refreshScheduler: RefreshScheduler\n\n  private fetchTokenPromise?: Promise<ApiTokenInfo>\n  private debug: IDebugger\n\n  constructor(\n    fetchTokenInfo: () => Promise<ApiTokenInfo>,\n    onTokenRefresh: (apiToken: string) => void,\n    delayBuffer: number,\n    apiTokenStore: ApiTokenStore,\n    refreshScheduler: RefreshScheduler\n  ) {\n    this.fetchTokenInfo = fetchTokenInfo\n    this.onTokenRefresh = onTokenRefresh\n    this.delayBuffer = delayBuffer\n    this.apiTokenStore = apiTokenStore\n    this.refreshScheduler = refreshScheduler\n\n    this.debug = debugFactory(\"dfuse:token-manager\")\n  }\n\n  public release(): void {\n    this.debug(\"Releasing default API token manager\")\n    this.refreshScheduler.release()\n    this.apiTokenStore.release()\n  }\n\n  public async getTokenInfo(): Promise<ApiTokenInfo> {\n    const tokenInfo = await this.apiTokenStore.get()\n    if (tokenInfo && !isApiTokenExpired(tokenInfo)) {\n      this.maybeScheduleNextRefresh(tokenInfo, { forceRefresh: false })\n\n      this.debug(\"Returning token found in API token store since it was still valid\")\n      return Promise.resolve(tokenInfo)\n    }\n\n    this.debug(\"Returning a fresh API token as it was not present in store or expired\")\n    return await this.refreshToken()\n  }\n\n  private async refreshToken(): Promise<ApiTokenInfo> {\n    const tokenInfo = await this.internalFetchToken()\n    this.debug(\n      \"Retrieved an API token that is going to expires at %s (%s)\",\n      new Date(tokenInfo.expires_at * 1000),\n      tokenInfo.token\n    )\n\n    this.maybeScheduleNextRefresh(tokenInfo, { forceRefresh: true })\n\n    try {\n      this.debug(\"Storing API token into token storage\")\n      await this.apiTokenStore.set(tokenInfo)\n    } catch (error) {\n      this.debug(\"Storing token into storage failed %s (%o)\", error, error)\n    }\n\n    this.debug(\"Notifying upstream listener that API token has been refreshed.\")\n    this.onTokenRefresh(tokenInfo.token)\n\n    return tokenInfo\n  }\n\n  private maybeScheduleNextRefresh(tokenInfo: ApiTokenInfo, options: { forceRefresh: boolean }) {\n    if (!options.forceRefresh && this.refreshScheduler.hasScheduledJob()) {\n      return\n    }\n\n    const delayInSeconds = this.getRefreshDelayInSeconds(tokenInfo)\n    const refreshAt = new Date(Date.now() + delayInSeconds * 1000)\n\n    this.debug(\n      \"Scheduling next token refresh to occur at %s (in %s seconds)\",\n      refreshAt,\n      delayInSeconds\n    )\n\n    this.refreshScheduler.schedule(delayInSeconds, () => this.refreshToken())\n  }\n\n  private getRefreshDelayInSeconds(tokenInfo: ApiTokenInfo) {\n    const nowInSeconds = Math.floor(Date.now() / 1000)\n\n    return (tokenInfo.expires_at - nowInSeconds) * this.delayBuffer\n  }\n\n  private async internalFetchToken(): Promise<ApiTokenInfo> {\n    if (this.fetchTokenPromise !== undefined) {\n      return this.fetchTokenPromise\n    }\n\n    this.fetchTokenPromise = new Promise<ApiTokenInfo>((resolve, reject) => {\n      this.fetchTokenInfo()\n        .then((apiTokenInfo: ApiTokenInfo) => {\n          this.fetchTokenPromise = undefined\n          resolve(apiTokenInfo)\n        })\n        .catch((error: any) => {\n          this.fetchTokenPromise = undefined\n          reject(error)\n        })\n    })\n\n    return this.fetchTokenPromise\n  }\n}\n\nclass NoopApiTokenManager implements ApiTokenManager {\n  private token: string\n  private expiresAt: number\n  private debug: IDebugger\n\n  constructor(token: string) {\n    this.token = token || \"a.b.c\"\n    this.expiresAt = 0\n    this.debug = debugFactory(\"dfuse:token-manager-noop\")\n  }\n\n  public release(): void {\n    this.debug(\"Releasing default API token manager\")\n  }\n\n  public async getTokenInfo(): Promise<ApiTokenInfo> {\n    return { token: this.token, expires_at: this.expiresAt }\n  }\n}\n","export type ErrorData = {\n  code: string\n  trace_id?: string\n  message: string\n  details?: { [key: string]: any }\n}\n\nexport class DfuseError extends Error {\n  public description: string\n  public cause?: Error\n\n  constructor(message: string, cause?: Error) {\n    super(message)\n\n    this.description = message\n    this.cause = cause\n  }\n}\n\nexport class DfuseApiError extends DfuseError implements ErrorData {\n  public code: string\n  public trace_id?: string\n  public message: string\n  public details?: { [key: string]: any }\n\n  constructor(data: ErrorData, cause?: Error) {\n    super(data.message, cause)\n\n    this.code = data.code\n    this.trace_id = data.trace_id\n    this.message = data.message\n    this.details = data.details\n  }\n}\n\nexport class DfuseClientError extends DfuseError {\n  constructor(message: string, cause?: Error) {\n    super(message, cause)\n  }\n}\n\nexport class DfuseSocketError extends DfuseError {\n  constructor(message: string, cause?: Error) {\n    super(message, cause)\n  }\n}\n","import { DfuseClientError } from \"../types/error\"\n\nexport type OutboundMessage<T = unknown> = {\n  type: OutboundMessageType\n  req_id: string\n  listen?: boolean\n  fetch?: boolean\n  start_block?: number\n  with_progress?: number\n  data: T\n}\n\n// **Important** The key must be the same as the API type but in upper snake case for \"in\" operation to work\nexport enum OutboundMessageType {\n  GET_ACTION_TRACES = \"get_action_traces\",\n  GET_TABLE_ROWS = \"get_table_rows\",\n  GET_TRANSACTION_LIFECYCLE = \"get_transaction_lifecycle\",\n  GET_HEAD_INFO = \"get_head_info\",\n  UNLISTEN = \"unlisten\"\n}\n\nexport type StreamOptions = {\n  req_id?: string\n  fetch?: boolean\n  listen?: boolean\n  start_block?: number\n  with_progress?: number\n  irreversible_only?: boolean\n}\n\nexport type GetActionTracesMessageData = {\n  accounts: string\n  receivers?: string\n  action_names?: string\n  with_dbops?: boolean\n  with_dtrxops?: boolean\n  with_ramops?: boolean\n  with_tableops?: boolean\n  with_inline_traces?: boolean\n}\n\nexport function getActionTracesMessage(\n  data: GetActionTracesMessageData,\n  streamOptions: StreamOptions = {}\n): OutboundMessage<GetActionTracesMessageData> {\n  return createOutboundMessage(OutboundMessageType.GET_ACTION_TRACES, data, {\n    listen: true,\n    ...streamOptions\n  })\n}\n\nexport type GetTableRowsMessageData = {\n  code: string\n  scope: string\n  table: string\n  json?: boolean\n  lower_bound?: string\n  upper_bound?: string\n}\n\n/**\n * @deprecated The message factories are deprecated, there is no need to create your\n *             own message anynore. This will be removed in a future release. The standard\n *             client does not use this anymore.\n */\nexport function getTableRowsMessage(\n  data: GetTableRowsMessageData,\n  streamOptions: StreamOptions = {}\n): OutboundMessage<GetTableRowsMessageData> {\n  return createOutboundMessage(OutboundMessageType.GET_TABLE_ROWS, data, {\n    listen: true,\n    ...streamOptions\n  })\n}\n\nexport type GetTransactionLifecycleMessageData = {\n  id: string\n}\n\n/**\n * @deprecated The message factories are deprecated, there is no need to create your\n *             own message anynore. This will be removed in a future release. The standard\n *             client does not use this anymore.\n */\nexport function getTransactionLifecycleMessage(\n  data: GetTransactionLifecycleMessageData,\n  streamOptions: StreamOptions = {}\n): OutboundMessage<GetTransactionLifecycleMessageData> {\n  return createOutboundMessage(OutboundMessageType.GET_TRANSACTION_LIFECYCLE, data, {\n    listen: true,\n    fetch: true,\n    ...streamOptions\n  })\n}\n\n/**\n * @deprecated The message factories are deprecated, there is no need to create your\n *             own message anynore. This will be removed in a future release. The standard\n *             client does not use this anymore.\n */\nexport function getHeadInfoMessage(streamOptions: StreamOptions = {}): OutboundMessage<{}> {\n  return createOutboundMessage(\n    OutboundMessageType.GET_HEAD_INFO,\n    {},\n    { listen: true, ...streamOptions }\n  )\n}\n\nexport type UnlistenMessageData = {\n  req_id: string\n}\n\n/**\n * @deprecated The message factories are deprecated, there is no need to create your\n *             own message anynore. This will be removed in a future release. The standard\n *             client does not use this anymore.\n */\nexport function unlistenMessage(data: UnlistenMessageData) {\n  return {\n    req_id: data.req_id,\n    type: OutboundMessageType.UNLISTEN,\n    data\n  }\n}\n\nexport type OutboundMessageFactory<T> = (\n  createOutboundMessage: (\n    type: OutboundMessageType,\n    data: T,\n    userOptions: StreamOptions\n  ) => OutboundMessage<T>,\n  withDefaultOptions: (userOptions: StreamOptions) => StreamOptions\n) => OutboundMessage<T>\n\n/**\n * Exported for consumption from internal packages. This does **not**\n * have any **Backward compatibility** policy nor documentation attached\n * to it.\n *\n * It will be moved and made private again when message factories\n * above have been removed.\n */\nexport function createOutboundMessage<T>(\n  type: OutboundMessageType,\n  data: T,\n  options: StreamOptions\n): OutboundMessage<T> {\n  const req_id = options.req_id\n  if (req_id === undefined) {\n    throw new DfuseClientError(\"All outbound message should have a 'req_id' value\")\n  }\n\n  return {\n    type,\n    req_id,\n    data,\n    ...options\n  }\n}\n","import { ApiTokenInfo } from \"../types/auth-token\"\nimport { DfuseClientError } from \"../types/error\"\n\n// These modules will be replaced by empty modules for an UMD build (Browser), check rollup.config.js `umdBuild`\nimport crypto from \"crypto\"\nimport fs from \"fs\"\nimport os from \"os\"\nimport path from \"path\"\n\n/**\n * A simple API token store interface supporting async operations. This\n * interface is used to store the API token when it has been refreshed\n * as well as retrieving a token from the store.\n *\n * By providing your own [[ApiTokenStore]] implementation, you can for\n * example easily store the token in the `localStorage` ([[LocalStorageApiTokenStore]]),\n * under `~/.dfuse/<sha256-api-key>/token.json` file ([[OnDiskApiTokenStore]]) or\n * more generically at any path ([[FileApiTokenStore]]).\n *\n * **Note** The [[OnDiskApiTokenStore]] and [[FileApiTokenStore]] are available\n * only on a Node.js environment.\n *\n * @kind Interfaces\n */\nexport interface ApiTokenStore {\n  /**\n   * Release any resources hold by this [[ApiTokenStore]] instance. Must\n   * be tolerant to being called multiple times.\n   *\n   * Once called, the instance is assumed unsuable and should never\n   * be invoked anymore.\n   */\n  release(): void\n\n  set: (apiTokenInfo: ApiTokenInfo) => Promise<void>\n  get: () => Promise<ApiTokenInfo | undefined>\n}\n\n/**\n * Represents an in-memory token storage concrete implementation of\n * a . This simply keep the token in variable and serves\n * it from there.\n *\n * It is **never** persisted and will be reset upon restart of the Browser tab\n * or process, leading to a new token being issued.\n *\n * You should try hard to use a persistent solution so that you re-use the\n * same token as long as it's valid.\n */\nexport class InMemoryApiTokenStore {\n  private apiTokenInfo?: ApiTokenInfo\n\n  public release(): void {\n    return\n  }\n\n  public async get(): Promise<ApiTokenInfo | undefined> {\n    return this.apiTokenInfo\n  }\n\n  public async set(apiTokenInfo: ApiTokenInfo): Promise<void> {\n    this.apiTokenInfo = apiTokenInfo\n  }\n}\n\n/**\n * Represents an [[ApiTokenStore]] that saves the token as a JSON string\n * in the `localStorage` of the Browser.\n *\n * Trying to use this class when `window.localStorage` is not a function\n * (like in a Node.js environment) will throw an error at construction\n * time. Use another implementation. If this error is thrown nonetheless\n * in your Browser, local storage is probably not supported there.\n *\n * It is persisted in the local storage of the Browser it will be picked up\n * upon restart of the Browser tab.\n */\nexport class LocalStorageApiTokenStore implements ApiTokenStore {\n  private key: string\n  private apiTokenInfo?: ApiTokenInfo\n\n  constructor(key: string) {\n    this.key = key\n\n    if (typeof localStorage !== \"object\") {\n      const messages = [\n        \"This environment does not contain a valid `localStorage` object in the global scope to use.\",\n        \"\",\n        \"You are most likely in a Node.js environment where a global `localStorage` is not available by default.\",\n        \"This API token store concrete impelementation is not usable in your environment. You should be\",\n        \"providing a different implementation of ApiTokenInfo.\",\n        \"\",\n        \"If this error occurred when you did not provide yourself the instance, it means our auto-detection\",\n        \"mechanism incorrectly thought it could use `LocalStorageApiTokenStore` instance while it should\",\n        \"have not. Please report a bug about this issue so we can fix it.\",\n        \"\",\n        \"If you provided the instance yourself, you should read our documentation to better\",\n        \"understand what you should provide here.\",\n        \"\",\n        \"See https://github.com/dfuse-io/client-js\"\n      ]\n\n      throw new DfuseClientError(messages.join(\"\\n\"))\n    }\n  }\n\n  public release(): void {\n    return\n  }\n\n  public async get(): Promise<ApiTokenInfo | undefined> {\n    if (this.apiTokenInfo !== undefined) {\n      return this.apiTokenInfo\n    }\n\n    const raw = localStorage.getItem(this.key)\n    if (raw == null) {\n      return undefined\n    }\n\n    this.apiTokenInfo = JSON.parse(raw)\n\n    return this.apiTokenInfo\n  }\n\n  public async set(apiTokenInfo: ApiTokenInfo): Promise<void> {\n    this.apiTokenInfo = apiTokenInfo\n    localStorage.setItem(this.key, JSON.stringify(apiTokenInfo))\n  }\n}\n\n/**\n * Represents an [[ApiTokenStore]] implementation that will save\n * as a JSON string in plain text in the given file.\n *\n * The directory structure is created when it does not exists.\n *\n * **Note** This cannot be used in a browser environment\n */\nexport class FileApiTokenStore implements ApiTokenStore {\n  private filePath: string\n  private apiTokenInfo?: ApiTokenInfo\n\n  constructor(filePath: string) {\n    this.filePath = filePath\n  }\n\n  public release(): void {\n    return\n  }\n\n  public async get(): Promise<ApiTokenInfo | undefined> {\n    if (this.apiTokenInfo !== undefined) {\n      return this.apiTokenInfo\n    }\n\n    const data = await readData(this.filePath)\n    if (data === undefined) {\n      return undefined\n    }\n\n    this.apiTokenInfo = JSON.parse(data)\n\n    return this.apiTokenInfo\n  }\n\n  public async set(apiTokenInfo: ApiTokenInfo): Promise<void> {\n    this.apiTokenInfo = apiTokenInfo\n\n    await writeData(this.filePath, JSON.stringify(apiTokenInfo))\n  }\n}\n\n/**\n * Represents an [[ApiTokenStore]] implementation that will save\n * as a JSON string in a file located at\n * `~/.dfuse/<sha256-api-key>/token.json`.\n *\n * The directory structure is created when it does not exists.\n *\n * **Note** This cannot be used in a browser environment.\n */\nexport class OnDiskApiTokenStore extends FileApiTokenStore {\n  constructor(apiKey: string) {\n    const homeDirectory = os.homedir()\n    const sha256sum = crypto.createHash(\"sha256\")\n\n    super(`${homeDirectory}/.dfuse/${sha256sum.update(apiKey).digest(\"hex\")}/token.json`)\n  }\n}\n\nasync function readData(filePath: string): Promise<string | undefined> {\n  return new Promise<string | undefined>((resolve, reject) => {\n    if (!fs.existsSync(filePath)) {\n      resolve(undefined)\n      return\n    }\n\n    fs.readFile(filePath, (error: any, data: any) => {\n      error ? reject(error) : resolve(data)\n    })\n  })\n}\n\nasync function writeData(filePath: string, data: string): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    try {\n      mkdirpSync(path.dirname(filePath))\n    } catch (error) {\n      reject(error)\n      return\n    }\n\n    fs.writeFile(filePath, data, (error: any) => {\n      error ? reject(error) : resolve()\n    })\n  })\n}\n\nasync function mkdirpSync(directory: string) {\n  if (!path.isAbsolute(directory)) {\n    return\n  }\n\n  const parent = path.join(directory, \"..\")\n  if (parent !== path.join(\"/\") && !fs.existsSync(parent)) {\n    mkdirpSync(parent)\n  }\n\n  if (!fs.existsSync(directory)) {\n    fs.mkdirSync(directory)\n  }\n}\n","import { DfuseError, DfuseClientError, DfuseApiError } from \"../types/error\"\nimport {\n  Fetch,\n  HttpResponse,\n  HttpQueryParameters,\n  HttpClient,\n  HttpHeaders\n} from \"../types/http-client\"\nimport debugFactory, { IDebugger } from \"debug\"\n\n/**\n * The set of options that can be used when constructing a the default\n * [[HttpClient]] instance through the [[createHttpClient]] factory\n * method.\n */\nexport interface HttpClientOptions {\n  /**\n   * The `fetch` function to use to make the actual low-level HTTP\n   * request.\n   *\n   * **Inferrence**<br><br>\n   * When not provided (default), the `fetch` to use is actually inferred\n   * based on the runtime environment.\n   *\n   * If a `window.fetch` function exists, which should be the case on a Browser\n   * environment, it will be used.\n   *\n   * If a `global.fetch` function exists, which can be the case upon a\n   * `global.fetch = ...` call at the bootstrap phase in a Node.js environment,\n   * it will be used\n   *\n   * Finally, if no `fetch` function could be determined, a [[DfuseError]] is\n   * thrown with a message explaining the situtation and a link to the documentation\n   * on how to solve the problem.\n   *\n   * @default `undefined` (Inferred based on environment, see `Inferrence` note above)\n   */\n  fetch?: Fetch\n}\n\n/**\n * Create the default [[HttpClient]] concrete implementation.\n *\n * @param authUrl The full dfuse Authentication url to use to perform the `authRequest` calls.\n * @param apiUrl The full dfuse REST API url to use to perform the `apiRequest` calls.\n * @param options The set of options used to construct the default [[HttpClient]] instance. See\n * [[HttpClientOptions]] for documentation of the options and default values for each of them.\n */\nexport function createHttpClient(\n  authUrl: string,\n  apiUrl: string,\n  options: HttpClientOptions = {}\n): HttpClient {\n  return new DefaultHttpClient(authUrl, apiUrl, inferFetch(options.fetch))\n}\n\nfunction inferFetch(fetch?: Fetch): Fetch {\n  const debug = debugFactory(\"dfuse:http\")\n\n  if (fetch !== undefined) {\n    debug(\"Using user provided `fetch` option.\")\n    return fetch\n  }\n\n  // In both of the condition below to determine a global `fetch` to use,\n  // we bind the `fetch` method to the global scope (either `window` or `global`\n  // depending on the target environment).\n  //\n  // It happens in a bundler environment like WebPack that the `fetch` method\n  // loses it's contextual `this` variable. The `this` is used internal by the\n  // implementation for certain features of the specification.\n  //\n  // By doing a `.bind(<global scope>)`, we ensure the `fetch` remains bound\n  // to the correct `this` variable.\n\n  // If we are in a Browser environment and `fetch` is available, use it\n  if (typeof window !== \"undefined\" && window.fetch != null) {\n    debug(\"Using `fetch` global value found on 'window' variable (Browser environment).\")\n    return window.fetch.bind(window)\n  }\n\n  // If we are in a Node.js like environment and `fetch` is available, use it\n  if (typeof global !== \"undefined\" && (global as any).fetch != null) {\n    debug(\"Using `fetch` global value found on 'global' variable (Node.js environment).\")\n    return (global as any).fetch.bind(global)\n  }\n\n  // Otherwise, throw an exception\n  const messages = [\n    \"You did not provide a `fetch` option and we were not able to infer one from the global scope.\",\n    \"\",\n    \"You are most likely in a Node.js environment where a global `fetch` is not available by defaut.\",\n    \"To resolve the issue, either pass a compatible `fetch` option or globally defined a `global.fetch`\",\n    \"variable pointing to a compatible `fetch` method.\",\n    \"\",\n    \"We invite you to read our documentation to learn more about this problem.\",\n    \"\",\n    \"See https://github.com/dfuse-io/client-js#nodejs\"\n  ]\n\n  throw new DfuseClientError(messages.join(\"\\n\"))\n}\n\n/**\n * The `DefaultHttpClient` is responsible of performing the actual HTTP\n * calls transforming the parameters into an actual HTTP request and\n * turning back the HTTP response into a return value.\n *\n * All methods are asynchronous and returns a response object when successufl\n * and throws a `DfuseError` when an error is encountered.\n */\nclass DefaultHttpClient {\n  protected authUrl: string\n  protected apiUrl: string\n  protected fetch: Fetch\n\n  private debug: IDebugger = debugFactory(\"dfuse:http\")\n\n  constructor(authUrl: string, apiUrl: string, fetch: Fetch) {\n    this.authUrl = authUrl\n    this.apiUrl = apiUrl\n    this.fetch = fetch\n  }\n\n  public release(): void {\n    return\n  }\n\n  public async authRequest<T>(\n    path: string,\n    method: string,\n    params?: HttpQueryParameters,\n    body?: any,\n    headers?: HttpHeaders\n  ): Promise<T> {\n    return this.request<T>(undefined, this.authUrl + path, method, params, body, headers)\n  }\n\n  public async apiRequest<T>(\n    apiToken: string,\n    path: string,\n    method: string,\n    params?: HttpQueryParameters,\n    body?: any,\n    headers?: HttpHeaders\n  ): Promise<T> {\n    return this.request<T>(apiToken, this.apiUrl + path, method, params, body, headers)\n  }\n\n  private async request<T>(\n    apiToken: string | undefined,\n    url: string,\n    method: string,\n    params?: HttpQueryParameters,\n    body?: any,\n    headers?: HttpHeaders\n  ): Promise<T> {\n    this.debug(\"Preparing request [%s %s](%o)\", method, url, params)\n\n    if (params && Object.keys(params).length > 0) {\n      url += \"?\" + this.queryParams(params)\n    }\n\n    const defaultHeaders: HttpHeaders = {}\n    if (apiToken !== undefined) {\n      defaultHeaders.Authorization = `Bearer ${apiToken}`\n    }\n\n    const userHeaders = headers || {}\n    const mergedHeaders = { ...defaultHeaders, ...userHeaders }\n\n    let transformedBody: string | undefined\n    if (body !== undefined) {\n      const contentType = this.getHeaderValue(mergedHeaders, \"content-type\")\n      if (contentType === undefined || contentType === \"application/json\") {\n        transformedBody = JSON.stringify(body)\n      } else if (contentType === \"application/x-www-form-urlencoded\") {\n        transformedBody = this.formEncodedBody(body)\n      } else {\n        transformedBody = body\n      }\n    }\n\n    try {\n      this.debug(\n        \"Executing request [%s %s](headers: %o, bodyLength: %s)\",\n        method,\n        url,\n        mergedHeaders,\n        (transformedBody || \"\").length\n      )\n\n      const response = await this.fetch(url, {\n        headers: mergedHeaders,\n        method,\n        body: transformedBody\n      })\n\n      this.debug(\n        \"Received response [%s %s %s](headers: %o)\",\n        response.status,\n        response.statusText,\n        response.url,\n        response.headers\n      )\n\n      if (!response.ok) {\n        this.debug(\"Request returned with an error HTTP code %s\", response.status)\n        throw await this.bodyToApiError(response)\n      }\n\n      this.debug(\"Turning response body into response result\")\n      return await this.bodyToResponse<T>(response)\n    } catch (error) {\n      if (error instanceof DfuseError) {\n        throw error\n      }\n\n      throw new DfuseClientError(\"Unable to perform HTTP request correctly\", error)\n    }\n  }\n\n  private async bodyToResponse<T>(response: HttpResponse): Promise<T> {\n    try {\n      return await response.json()\n    } catch (error) {\n      throw new DfuseClientError(\"The returned body shall have been a valid JSON object\", error)\n    }\n  }\n\n  private async bodyToApiError(response: HttpResponse): Promise<DfuseError> {\n    const body = await response.text()\n\n    try {\n      return new DfuseApiError(JSON.parse(body))\n    } catch (error) {\n      return new DfuseClientError(\n        `The returned body shall have been a valid JSON object, got '${body}'`,\n        error\n      )\n    }\n  }\n\n  private queryParams(params: HttpQueryParameters) {\n    const entries = []\n    for (const key of Object.keys(params)) {\n      const value = params[key]\n      if (value !== undefined) {\n        entries.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(value))\n      }\n    }\n\n    return entries.join(\"&\")\n  }\n\n  private formEncodedBody(fields: HttpQueryParameters): string {\n    const entries = []\n    for (const key of Object.keys(fields)) {\n      const value = fields[key]\n      if (value !== undefined) {\n        entries.push(key + \"=\" + value)\n      }\n    }\n\n    return entries.join(\"&\")\n  }\n\n  // FIXME: In real world scenario, an HTTP header can appear more than onced, but we do not\n  //        deal with this case here yet.\n  private getHeaderValue(headers: HttpHeaders, key: string): string | undefined {\n    for (const candidateKey in headers) {\n      if (candidateKey.toLowerCase() === key.toLowerCase()) {\n        return headers[candidateKey]\n      }\n    }\n\n    return undefined\n  }\n\n  private hasHeaderKey(headers: HttpHeaders, key: string): boolean {\n    return this.getHeaderValue(headers, key) !== undefined\n  }\n}\n","export const V1_AUTH_ISSUE = \"/v1/auth/issue\"\n\nexport const V0_FETCH_BLOCK_ID_BY_TIME = \"/v0/block_id/by_time\"\nexport const V0_FETCH_TRANSACTION = \"/v0/transactions/:id\"\n\nexport const V0_STATE_ABI = \"/v0/state/abi\"\nexport const V0_STATE_ABI_BIN_TO_JSON = \"/v0/state/abi/bin_to_json\"\n\nexport const V0_STATE_KEY_ACCOUNTS = \"/v0/state/key_accounts\"\nexport const V0_STATE_PERMISSION_LINKS = \"/v0/state/permission_links\"\n\nexport const V0_STATE_TABLE = \"/v0/state/table\"\nexport const V0_STATE_TABLE_ROW = \"/v0/state/table/row\"\nexport const V0_STATE_TABLES_SCOPES = \"/v0/state/tables/scopes\"\nexport const V0_STATE_TABLES_ACCOUNTS = \"/v0/state/tables/accounts\"\nexport const V0_STATE_TABLE_SCOPES = \"/v0/state/table_scopes\"\n\nexport const V0_SEARCH_TRANSACTIONS = \"/v0/search/transactions\"\n\n/**\n * An interface used to interact with dfuse REST API.\n *\n * Created mainly to abstract implementation details of dealing\n * with HTTP request/response, enable consumer of the library to\n * provide their own implementation of an HTTP client (think about\n * providing `Fetch` interface instead).\n *\n * @group Interfaces\n */\nexport interface HttpClient {\n  /**\n   * Release any resources hold by this [[HttpClient]] instance. Must\n   * be tolerant to being called multiple times.\n   *\n   * Once called, the instance is assumed unsuable and should never\n   * be invoked anymore.\n   */\n  release(): void\n\n  /**\n   * Make an anonymous request (unauthenticated) to the dfuse Authentication endpoint.\n   * Usually used only for issuing an API token from an API key.\n   *\n   * @param path (required) The HTTP path on the endpoint\n   * @param method (required) The HTTP method to perform the request agaisnt\n   * @param params (defaults `{}`) The HTTP query parameters to append to the url, they will\n   * be url-encoded and included in the final remote url. Has no effect when empty or undefined.\n   * @param body (defaults `undefined`) The HTTP body to include in the request, assumed to be a\n   * JSON object that will be serialized to a string. Not included in the HTTP request when `undefined`.\n   * @param headers (defaults `{}`) The extra HTTP headers to include in the request. Those will be merged\n   * with default ones (`{ Authorization: ... }`) and they override them if same key are specified.\n   *\n   * @returns A `Promise` that will resolve to the response body if it passes. Will reject with a\n   * [[DfuseApiError]] if it fits the dfuse Error Format or a generic `DfuseError` is it's something\n   * not fitting our expected format.\n   */\n  authRequest<T>(\n    path: string,\n    method: string,\n    params?: HttpQueryParameters,\n    body?: any,\n    headers?: HttpHeaders\n  ): Promise<T>\n\n  /**\n   * Make an authenticated request (unauthenticated) to the dfuse REST endpoint.\n   *\n   * Upon a succesfull call, the actual response body (expected to be a valid JSON) will\n   * be returned to the caller.\n   *\n   * Upon an error, a [[DfuseError]] is returned, will be a [[DfuseApiError]] if the response's\n   * body exist, it's a valid JSON string and it fits the dfuse error format.\n   *\n   * @param apiToken The API token used to to interact with the API endpoint. The token will be turned\n   * into a proper HTTP header `Authorization: Bearer ...`.\n   * @param path (required) The HTTP path on the endpoint\n   * @param method (required) The HTTP method to perform the request agaisnt\n   * @param params (defaults `{}`) The HTTP query parameters to append to the url, they will\n   * be url-encoded and included in the final remote url. Has no effect when empty or undefined.\n   * @param body (defaults `undefined`) The HTTP body to include in the request, assumed to be a\n   * JSON object that will be serialized to a string. Not included in the HTTP request when `undefined`.\n   * @param headers (defaults `{}`) The extra HTTP headers to include in the request. Those will be merged\n   * with default ones (`{ Authorization: ... }`) and they override them if same key are specified.\n   *\n   * @returns A `Promise` that will resolve to the response body if it passes. Will reject with a\n   * [[DfuseApiError]] if it fits the dfuse Error Format or a generic `DfuseError` is it's something\n   * not fitting our expected format.\n   */\n  apiRequest<T>(\n    apiToken: string,\n    path: string,\n    method: string,\n    params?: HttpQueryParameters,\n    body?: any,\n    headers?: HttpHeaders\n  ): Promise<T>\n}\n\nexport type HttpHeaders = Record<string, string>\nexport type HttpQueryParameters = Record<string, any>\n\n/**\n * This interface is the bare minimum as required by our internal usage.\n *\n * This is copied to ensure minimal compatiblity with `fetch` is required\n * and thus, it's required to provide a full clone of `fetch` handling.\n * To avoid that problem of over-complexifying , we define a small interface of what we really use\n * inside the library. It's the only part's that are needed.\n *\n * Passing the `window.fetch` (in the Browser) or `global.fetch` (polyfilled in Node.js)\n * should always be accepted as a valid usage.\n *\n * @ignore\n */\nexport type Fetch = (url: string, options?: RequestInit) => Promise<HttpResponse>\n\nexport type RequestInit = {\n  body?: any\n  headers?: any\n  method?: string\n}\n\n/**\n * @ignore\n */\nexport interface HttpBody {\n  json(): Promise<any>\n  text(): Promise<string>\n}\n\n/**\n * @ignore\n */\nexport type HttpResponse = {\n  readonly headers: any\n  readonly ok: boolean\n  readonly status: number\n  readonly statusText: string\n  readonly url: string\n} & HttpBody\n","import debugFactory, { IDebugger } from \"debug\"\nimport { DfuseClientError, DfuseSocketError } from \"../types/error\"\nimport {\n  WebSocket,\n  Socket,\n  SocketMessageListener,\n  WebSocketFactory,\n  SocketConnectOptions\n} from \"../types/socket\"\n\nexport interface SocketOptions {\n  /**\n   * An id to assign to this socket instance. This is used through the `debug`\n   * package to display a different `debug` tag when provided (i.e. `dfuse:socket:<id>`).\n   *\n   * @default `undefined`\n   */\n  id?: string\n\n  /**\n   * Determines if the socket should automatically re-connect with the upstream\n   * service upon an abnormal disconnection.\n   *\n   * The re-connection happens after the given [[SocketOptions.reconnectDelayInMs]]\n   * has elapsed.\n   *\n   * @default `true`\n   */\n  autoReconnect?: boolean\n\n  /**\n   * The delay after the abnormal closure of the connection before trying a\n   * re-connection. As no effect if [[SocketOptions.autoReconnect]] is sets\n   * to `false`.\n   *\n   * @default `2.5s` (See [[DEFAULT_RECONNECT_DELAY_IN_MS]])\n   */\n  reconnectDelayInMs?: number\n\n  /**\n   * Whether `ping` messages should be send automatically at regular interval\n   * by the [[Socket]] instance. The actual interval used can be defined by\n   * providing the [[SocketOptions.keepAliveIntervalInMs]] option.\n   *\n   * @default `true`\n   */\n  keepAlive?: boolean\n\n  /**\n   * The interval of time at which `ping` messages are automatically sent to\n   * the remote endpoint. This is time that elapsed between two consecutives\n   * `ping` messages.\n   *\n   * As no effect if [[SocketOptions.keepAlive]] is sets to `false`.\n   *\n   * @default `30s` (See [[DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS]])\n   */\n  keepAliveIntervalInMs?: number\n\n  /**\n   * The set of webSocket protocols we want to send when performing the\n   * connection handshake. For example, GraphQL subscription over WebSocket\n   * uses \"graphql-ws\" protocol while standard WebSocket connection can\n   * pass `undefined` as the value.\n   *\n   * @default `undefined`\n   */\n  webSocketProtocols?: string | string[]\n\n  /**\n   * A factory method used to create the `WebSocket` instance that should be\n   * used by the [[Socket]] instance.\n   *\n   * **Inferrence**<br><br>\n   * When not provided (default), the factory to use is actually inferred\n   * based on the runtime environment.\n   *\n   * If a `window.WebSocket` variable exists, which should be the case on a Browser\n   * environment, the factory used will call `new window.WebSocket(...)` to instantiate\n   * the `WebSocket` instance.\n   *\n   * If a `global.WebSocket` variable exists, which can be the case upon a\n   * `global.WebSocket = ...` call at the bootstrap phase in a Node.js environment,\n   * the factory used will call `new global.WebSocket(...)` to instantiate\n   * the `WebSocket` instance.\n   *\n   * Finally, if no `WebSocket` instance could be determined, a [[DfuseError]] is\n   * thrown with a message explaining the situtation and a link to the documentation\n   * on how to solve the problem.\n   *\n   * @default `undefined` (Inferred based on environment, see `Inferrence` note above)\n   */\n  webSocketFactory?: WebSocketFactory\n\n  /**\n   * A callback that can be provided to be notified when the [[Socket]] just performed\n   * a re-connection. This will be called after a successful re-connection. When the callback\n   * is invoked, the connection with the server has actually resumed and stream can be\n   * restarted or other actions can be taken.\n   *\n   * This is a post re-connection callback.\n   *\n   * @default `() => {}` (noop)\n   */\n  onReconnect?: () => void\n\n  /**\n   * A callback that can be provided to be notified when the [[Socket]] receives an\n   * error event. The error event is always emitted only where an error occurred with\n   * the connection. It is not emitted on a normal and expected disconnection with\n   * the server (when closing the underlying socket for example).\n   *\n   * The callback will be invoked with the actual event as defined by the `WebSocket`\n   * instance used.\n   *\n   * **Important Note**<br><br>\n   * The actual `event` object you will receive is different wheter you use\n   * the Browser `WebSocket` instance ([ErrorEvent](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/error_event))\n   * or depending on the Node.js library you use (If you use [ws](https://www.npmjs.com/package/ws) package, then it's\n   * [ErrorEvent](https://github.com/websockets/ws/blob/master/lib/event-target.js#L87))\n   *\n   * @default `() => {}` (noop)\n   */\n  onError?: (event: object) => void\n\n  /**\n   * A callback that can be provided to be notified when the [[Socket]] receives a\n   * close event. The close event is always emitted even when an error has occurred, it\n   * will however always come **after** the error event.\n   *\n   * The callback will be invoked with the actual event as defined by the `WebSocket`\n   * instance used.\n   *\n   * **Important Note**<br><br>\n   * The actual `event` object you will receive is different wheter you use\n   * the Browser `WebSocket` instance ([CloseEvent](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close_event))\n   * or depending on the Node.js library you use (If you use [ws](https://www.npmjs.com/package/ws) package, then it's\n   * [CloseEvent](https://github.com/websockets/ws/blob/master/lib/event-target.js#L47))\n   *\n   * @default `() => {}` (noop)\n   */\n  onClose?: (event: object) => void\n}\n\n// @deprecated Please use SocketConnectOptions instead, will be removed eventually\nexport type ConnectOptions = SocketConnectOptions\n\n/**\n * Create an actual [[Socket]] instance that will be used as the interface to wrap all\n * communicaton of the WebSocket protocol.\n *\n * @param url The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter.\n * @param options The options used to configure the [[Socket]] instance, see [[SocketOptions]] for default options.\n */\nexport function createSocket(url: string, options: SocketOptions = {}): Socket {\n  return new DefaultSocket(url, {\n    id: \"\",\n    autoReconnect: true,\n    reconnectDelayInMs: DEFAULT_RECONNECT_DELAY_IN_MS,\n    keepAlive: true,\n    keepAliveIntervalInMs: DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS,\n    webSocketFactory: inferWebSocketFactory(\n      options.id,\n      options.webSocketProtocols,\n      options.webSocketFactory\n    ),\n    ...options\n  })\n}\n\nfunction inferWebSocketFactory(\n  id: string | undefined,\n  webSocketProtocols?: string | string[],\n  webSocketFactory?: WebSocketFactory\n): WebSocketFactory {\n  const debug = debugFactory(\"dfuse:socket\" + (id ? `:${id}` : \"\"))\n\n  if (webSocketFactory !== undefined) {\n    debug(\"Using user provided `webSocketFactory` option.\")\n    return webSocketFactory\n  }\n\n  // If we are in a Browser environment and `WebSocket` is available, use it\n  if (typeof window !== \"undefined\" && (window as any).WebSocket != null) {\n    debug(\"Using `WebSocket` global value found on 'window' variable (Browser environment).\")\n    return async (url: string) => new (window as any).WebSocket(url, webSocketProtocols)\n  }\n\n  // If we are in a Node.js like environment and `WebSocket` is available, use it\n  if (typeof global !== \"undefined\" && (global as any).WebSocket != null) {\n    debug(\"Using `WebSocket` global value found on 'global' variable (Node.js environment).\")\n    return async (url: string) => new (global as any).WebSocket(url, webSocketProtocols, {})\n  }\n\n  // Otherwise, throw an exception\n  const messages = [\n    \"You did not provide a `webSocket` option and we were not able find a `WebSocket` object in\",\n    \"the global scope to create use.\",\n    \"\",\n    \"You are most likely in a Node.js environment where a global `WebSocket` is not available by default.\",\n    \"To resolve the issue, either pass a compatible `webSocket` option or globally defined a `global.WebSocket`\",\n    \"variable pointing to a compatible `WebSocket` client.\",\n    \"\",\n    \"We invite you to read our documentation to learn more about this problem.\",\n    \"\",\n    \"See https://github.com/dfuse-io/client-js#nodejs\"\n  ]\n\n  throw new DfuseClientError(messages.join(\"\\n\"))\n}\n\nconst noop = () => {\n  return\n}\n\ntype Resolver<T> = (value?: T | PromiseLike<T>) => void\ntype Rejecter = (reason?: any) => void\n\nexport const DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS = 30000 // 30s\nexport const DEFAULT_RECONNECT_DELAY_IN_MS = 2500 // 2.5s\n\nclass DefaultSocket implements Socket {\n  private url: string\n  private apiToken?: string\n  private options: SocketOptions\n\n  public isConnected: boolean = false\n  public disconnectInitiator?: \"client\" | \"server\"\n  public socket?: WebSocket\n\n  private debug: IDebugger\n  private listener?: SocketMessageListener\n  private onReconnectListener?: () => void\n  private onTerminationListener?: () => void\n  private intervalHandler?: any\n\n  private connectionPromise?: Promise<void>\n  private closePromise?: Promise<void>\n  private closeResolver?: Resolver<void>\n\n  public constructor(url: string, options: SocketOptions) {\n    this.url = url\n    this.options = options\n\n    this.debug = debugFactory(\"dfuse:socket\" + (options.id !== \"\" ? `:${options.id}` : \"\"))\n  }\n\n  public setApiToken(apiToken: string): void {\n    this.debug(\"Socket API token updated to %s.\", apiToken)\n    this.apiToken = apiToken\n  }\n\n  public async connect(\n    listener: SocketMessageListener,\n    options: SocketConnectOptions = {}\n  ): Promise<void> {\n    this.debug(\"About to connect to remote endpoint.\")\n    if (this.connectionPromise !== undefined) {\n      return this.connectionPromise\n    }\n\n    if (this.isConnected) {\n      return\n    }\n\n    this.listener = listener\n    this.onReconnectListener = options.onReconnect\n    this.onTerminationListener = options.onTermination\n\n    this.connectionPromise = new Promise<void>((resolve, reject) => {\n      this.debug(\"Connection promise started, creating and opening socket.\")\n      this.createAnOpenSocket(\n        this.onSocketConnectOpenFactory(resolve),\n        this.onSocketErrorFactory(reject),\n        this.onSocketCloseFactory(),\n        reject\n      )\n    })\n\n    this.debug(\"Connection to remote endpoint in-progress, returning promise to caller.\")\n    return this.connectionPromise\n  }\n\n  public async disconnect(): Promise<void> {\n    this.debug(\"About to disconnect from remote endpoint.\")\n    if (this.closePromise) {\n      this.debug(\"A disconnect is already in progress, joining it for termination.\")\n      return this.closePromise\n    }\n\n    if (this.socket === undefined) {\n      return\n    }\n\n    this.onReconnectListener = undefined\n    this.listener = undefined\n\n    this.debug(\"Closing socket.\")\n    this.socket.close()\n\n    // We must not clean up the socket at this point yet. Cleaning up the socket means\n    // removing the actual event listeners. If you clean up just yet, the `onclose` event\n    // will not be handled and the consumer of the library does not receive its own\n    // `onClose` event. Instead, let's do the clean up once we receive the socket\n    // `onclose` event.\n\n    this.debug(\n      \"Lazily disconnected, remaining clean up shall be performed when receiving `onclose` event.\"\n    )\n    this.isConnected = false\n    this.disconnectInitiator = \"client\"\n\n    this.closePromise = new Promise((resolve) => {\n      // Shall be resolved by the `onClose` event handler on this class\n      this.closeResolver = resolve\n    })\n\n    return this.closePromise\n  }\n\n  public async send<T = unknown>(message: T): Promise<void> {\n    if (!this.isConnected) {\n      this.debug(\"Not connected, re-connecting prior sending message.\")\n      await this.reconnect()\n    }\n\n    if (!this.isConnected) {\n      this.debug(\"Socket not connected, unable to send message correctly.\")\n      throw new DfuseSocketError(\"Socket not connected, unable to send message correctly.\")\n    }\n\n    this.debug(\"Sending message %o through socket.\", message)\n    this.socket!.send(JSON.stringify(message))\n  }\n\n  private async createAnOpenSocket(\n    onSocketOpen: () => void,\n    onSocketError: (event: Event) => void,\n    onSocketClose: (event: CloseEvent) => void,\n    onSocketFactoryError: (error: any) => void\n  ): Promise<void> {\n    const url = this.buildUrl()\n\n    this.debug(\"Starting connection handshake with remote url %s.\", url)\n    try {\n      const socket: WebSocket = await this.options.webSocketFactory!(url)\n\n      socket.onopen = onSocketOpen\n      socket.onerror = onSocketError\n      socket.onclose = onSocketClose\n      socket.onmessage = this.onSocketMessage\n\n      this.socket = socket\n    } catch (error) {\n      onSocketFactoryError(error)\n    }\n  }\n\n  private buildUrl(): string {\n    if (this.apiToken === undefined) {\n      // FIXME: Shall we throw an exception instead?\n      return this.url\n    }\n\n    // FIXME: Decompose url, add query param api token if available, then re-compose url!\n    if (this.url.includes(\"?\")) {\n      return `${this.url}&token=${this.apiToken}`\n    }\n\n    return `${this.url}?token=${this.apiToken}`\n  }\n\n  private onSocketConnectOpenFactory = (resolve: Resolver<void>) => () => {\n    this.debug(\"Received `onopen` (via connect) notification from socket.\")\n    this.isConnected = true\n    this.connectionPromise = undefined\n\n    if (this.keepAliveOption() === true) {\n      this.registerKeepAliveHandler()\n    }\n\n    this.debug(\"Signaling completion of `connect` method in the outer scope.\")\n    resolve()\n  }\n\n  private onSocketReconnectOpenFactory = (resolve: Resolver<boolean>) => () => {\n    this.debug(\n      \"Received `onopen` (via reconnect) notification from socket with ready state %d.\",\n      this.socket!.readyState\n    )\n    this.isConnected = true\n    this.connectionPromise = undefined\n\n    if (this.keepAliveOption() === true) {\n      this.registerKeepAliveHandler()\n    }\n\n    this.debug(\"Signaling completion of `reconnect` method in the outer scope.\")\n    resolve(true)\n\n    this.debug(\"Sending a `onReconnect` notification to client consumer.\")\n    this.onReconnect()\n  }\n\n  private onSocketErrorFactory = (reject: Rejecter) => (event: Event) => {\n    this.debug(\"Received `onerror` notification from socket (%s).\", (event as any).error)\n\n    // The official WebSocket flow is to always send an `onclose` event after an `onerror`\n    // ones, as such, we must not clean the socket at this point. We must always\n    // wait and ensures the `onclose` event will be called and that clean up will\n    // happen in the `onclose` handler.\n\n    this.debug(\"Signaling rejection of connection in the outer scope.\")\n    reject(event)\n\n    this.debug(\"Sending an `onError` notification to client consumer.\")\n    this.onError(event)\n  }\n\n  private onSocketReconnectErrorFactory = () => (event: Event) => {\n    this.debug(\"Received `onerror` (via reconnect) notification from socket.\")\n\n    this.debug(\"Sending an `onError` notification to client consumer.\")\n    this.onError(event)\n  }\n\n  private onSocketCloseFactory = () => {\n    return this.commonOnSocketCloseFactory(\"connect\", () => {\n      this.reconnect().catch((error) => {\n        this.debug(\"The re-connection never succeed, will not retry anymore.\", error)\n      })\n    })\n  }\n\n  private onSocketReconnectCloseFactory = (resolve: Resolver<void>, reject: Rejecter) => {\n    return this.commonOnSocketCloseFactory(\"reconnect\", () => {\n      this.tryReconnect(resolve, reject)\n    })\n  }\n\n  private commonOnSocketCloseFactory = (\n    tag: \"connect\" | \"reconnect\",\n    reconnectWorker: () => void\n  ) => (event: CloseEvent) => {\n    this.debug(\"Received `onclose` (via %s) notification from socket.\", tag)\n    this.isConnected = false\n    this.connectionPromise = undefined\n\n    if (this.closeResolver) {\n      this.debug(\"Resolving disconnect close promise (via %s).\", tag)\n      this.closeResolver()\n      this.closeResolver = undefined\n      this.closePromise = undefined\n    }\n\n    this.cleanSocket()\n\n    this.debug(\n      \"Sending a `onClose` (%d) notification to client consumer (via %s).\",\n      event.code,\n      tag\n    )\n    this.onClose(event)\n\n    if (\n      event.code !== 1000 &&\n      event.code !== 1009 &&\n      this.disconnectInitiator !== \"client\" &&\n      this.options.autoReconnect\n    ) {\n      this.debug(\n        \"Socket has close abnormally (via %s), trying to re-connect to socket (infinite retry).\",\n        tag\n      )\n\n      reconnectWorker()\n    } else {\n      this.debug(\"Terminating socket lifecycle (via %s), no reconnection will be attempted.\", tag)\n\n      if (this.onTerminationListener) {\n        this.onTerminationListener()\n      }\n\n      this.disconnectInitiator = undefined\n    }\n  }\n\n  private onSocketMessage = (event: MessageEvent) => {\n    let message: any\n    try {\n      message = JSON.parse(event.data) as { [key: string]: any }\n    } catch (error) {\n      this.debug(\"Received a non-JSON message, are you sure you are talking to dfuse API?\")\n      return\n    }\n\n    if (this.listener) {\n      this.listener(message)\n    }\n  }\n\n  private registerKeepAliveHandler() {\n    const keepAliveInterval =\n      this.options.keepAliveIntervalInMs || DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS\n\n    this.debug(\"Unregistering keep alive interval\")\n    this.intervalHandler = setInterval(() => {\n      if (!this.isConnected || this.socket === undefined) {\n        return\n      }\n\n      this.debug(\"Sending keep alive pong through socket.\")\n      this.socket.send(JSON.stringify({ type: \"pong\" }))\n    }, keepAliveInterval)\n  }\n\n  private unregisterKeepAliveHandler() {\n    if (this.intervalHandler === undefined) {\n      return\n    }\n\n    this.debug(\"Unregistering keep alive interval\")\n    clearInterval(this.intervalHandler)\n    this.intervalHandler = undefined\n  }\n\n  private async reconnect(): Promise<boolean> {\n    this.debug(\"Reconnect has been invoked, perfoming initial re-connection logic.\")\n    if (this.connectionPromise) {\n      try {\n        this.debug(\"Awaiting actual connection to complete.\")\n        await this.connectionPromise\n        return true\n      } catch (error) {\n        this.debug(\"Original connection did not succeed, continuing re-connection process.\")\n      }\n    }\n\n    if (!this.options.autoReconnect) {\n      this.debug(\"Not re-connecting because client consumer auto reconnect option is falsy.\")\n      return false\n    }\n\n    return new Promise<boolean>(this.tryReconnect)\n  }\n\n  private tryReconnect = (resolve: any, reject: any) => {\n    let reconnectDelay = this.options.reconnectDelayInMs\n    if (reconnectDelay === undefined) {\n      reconnectDelay = DEFAULT_RECONNECT_DELAY_IN_MS\n    }\n\n    this.debug(`Waiting ${reconnectDelay}ms before trying to perform the re-connection.`)\n    setTimeout(() => {\n      this.createAnOpenSocket(\n        this.onSocketReconnectOpenFactory(resolve),\n        this.onSocketReconnectErrorFactory(),\n        this.onSocketReconnectCloseFactory(resolve, reject),\n        reject\n      )\n    }, reconnectDelay)\n  }\n\n  private cleanSocket() {\n    if (this.intervalHandler !== undefined) {\n      this.unregisterKeepAliveHandler()\n    }\n\n    if (this.socket === undefined) {\n      return\n    }\n\n    this.socket.onopen = noop\n    this.socket.onclose = noop\n    this.socket.onerror = noop\n    this.socket.onmessage = noop\n\n    this.socket = undefined\n  }\n\n  /**\n   * We notify both the `onReconnect` option passed when constructing\n   * the socket and the one (if present) that was passed when connecting\n   * the socket.\n   *\n   * Those are two different listeners and must be both sent when possible.\n   */\n  private onReconnect() {\n    // Let's call the `connect` `onReconnectListener` first then followed\n    // by the one the consumer of the socket passed\n    if (this.onReconnectListener) this.onReconnectListener()\n    if (this.options.onReconnect) this.options.onReconnect()\n  }\n\n  private onClose(message: any) {\n    if (this.options.onClose) this.options.onClose(message)\n  }\n\n  private onError(message: any) {\n    if (this.options.onError) this.options.onError(message)\n  }\n\n  private keepAliveOption(): boolean {\n    return this.options.keepAlive === undefined ? true : this.options.keepAlive\n  }\n}\n","import { ProgressData } from \"../types/progress\"\nimport { ActionTraceData } from \"../types/action-trace\"\nimport { ErrorData } from \"../types/error\"\nimport { ListeningData } from \"../types/listen\"\nimport { HeadInfoData } from \"../types/head-info\"\nimport { TableDeltaData } from \"../types/table-delta\"\nimport { TableSnapshotData } from \"../types/table-snapshot\"\nimport { TransactionLifecycleData } from \"../types/transaction\"\n\nexport type InboundMessage<T = any> = {\n  type: InboundMessageType\n  req_id?: string\n  data: T\n}\n\n// **Important** The key must be the same as the API type but in upper snake case for \"in\" operation to work\nexport enum InboundMessageType {\n  ACTION_TRACE = \"action_trace\",\n  ERROR = \"error\",\n  LISTENING = \"listening\",\n  HEAD_INFO = \"head_info\",\n  PING = \"ping\",\n  PROGRESS = \"progress\",\n  UNLISTENED = \"unlistened\",\n  TABLE_DELTA = \"table_delta\",\n  TABLE_SNAPSHOT = \"table_snapshot\",\n  TRANSACTION_LIFECYCLE = \"transaction_lifecycle\"\n}\n\nexport interface ActionTraceInboundMessage<T = Record<string, any>>\n  extends InboundMessage<ActionTraceData<T>> {}\nexport interface ErrorInboundMessage extends InboundMessage<ErrorData> {}\nexport interface ListeningInboundMessage extends InboundMessage<ListeningData> {}\nexport interface HeadInfoInboundMessage extends InboundMessage<HeadInfoData> {}\nexport interface PingInboundMessage extends InboundMessage<{}> {}\nexport interface ProgressInboundMessage extends InboundMessage<ProgressData> {}\nexport interface UnlistenedInboundMessage extends InboundMessage<{}> {}\nexport interface TableDeltaInboundMessage<T = Record<string, any>>\n  extends InboundMessage<TableDeltaData<T>> {}\nexport interface TableSnapshotInboundMessage<T = Record<string, any>>\n  extends InboundMessage<TableSnapshotData<T>> {}\nexport interface TransactionLifecycleInboundMessage\n  extends InboundMessage<TransactionLifecycleData> {}\n\n// export type InboundMessageType = \"action_trace\"\n//                                | \"error\"\n//                                | \"listening\"\n//                                | \"head_info\"\n//                                | \"ping\"\n//                                | \"progress\"\n//                                | \"unlistened\"\n//                                | \"table_delta\"\n//                                | \"table_snapshot\"\n//                                | \"transaction_lifecycle\"\n","export class Deferred<T> {\n  private activePromise: Promise<T>\n  private resolver!: (value?: T | PromiseLike<T>) => void\n  private rejecter!: (reason?: any) => void\n\n  constructor() {\n    this.activePromise = new Promise((resolve, reject) => {\n      this.resolver = resolve\n      this.rejecter = reject\n    })\n  }\n\n  public promise(): Promise<T> {\n    return this.activePromise\n  }\n\n  public resolve(value?: T | PromiseLike<T>) {\n    this.resolver(value)\n  }\n\n  public reject(reason?: any) {\n    this.rejecter(reason)\n  }\n}\n","import debugFactory, { IDebugger } from \"debug\"\nimport { SocketOptions, createSocket } from \"./socket\"\nimport { OutboundMessage, unlistenMessage } from \"../message/outbound\"\nimport { InboundMessage, InboundMessageType } from \"../message/inbound\"\nimport { DfuseClientError } from \"../types/error\"\nimport { StreamClient, OnStreamMessage, OnStreamRestart } from \"../types/stream-client\"\nimport { Socket } from \"../types/socket\"\nimport { Stream, StreamMarker } from \"../types/stream\"\nimport { Deferred } from \"../helpers/promises\"\n\n/**\n * The set of options that can be used when constructing a the default\n * [[StreamClient]] instance through the [[createStreamClient]] factory\n * method.\n */\nexport interface StreamClientOptions {\n  /**\n   * The [[Socket]] instance to use, inferred based on the environment when not provided.\n   *\n   * @default `undefined` (Inferred based on runtime environment (Node.js/Browser), see [[createSocket]])\n   */\n  socket?: Socket\n\n  /**\n   * The [[SocketOptions]] to pass when creating the default [[Socket]] instance.\n   * This field has no effect if you provide yourself a [[StreamClientOptions.socket]] option.\n   *\n   * @default `undefined` (See [[SocketOptions]] for actual defaults this generates)\n   */\n  socketOptions?: SocketOptions\n\n  /**\n   * Determines all streams should automatically restart when the socket disconnects. The stream\n   * will re-connect at their latest marked value (See [[Stream.mark]]) if present or at current\n   * block if it was never marked.\n   *\n   * @default `true`\n   */\n  autoRestartStreamsOnReconnect?: boolean\n}\n\n/**\n * Create the default [[StreamClient]] concrete implementation.\n *\n * @param wsUrl The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter. Passed as\n * is to created [[Socket]] interface through the [[createSocket]] factory method. This parameter has no effect\n * if [[StreamClientOptions.socket]] options is used.\n * @param options The set of options used to construct the default [[StreamClient]] instance. See\n * [[StreamClientOptions]] for documentation of the options and default values for each of them.\n */\nexport function createStreamClient(wsUrl: string, options: StreamClientOptions = {}): StreamClient {\n  return new DefaultStreamClient(\n    options.socket || createSocket(wsUrl, { id: \"stream\", ...options.socketOptions }),\n    options.autoRestartStreamsOnReconnect === undefined\n      ? true\n      : options.autoRestartStreamsOnReconnect\n  )\n}\n\nclass DefaultStreamClient {\n  private socket: Socket\n  private autoRestartStreamsOnReconnect: boolean\n  private debug: IDebugger = debugFactory(\"dfuse:stream\")\n  private debugTrace: IDebugger = debugFactory(\"dfuse-trace:stream\")\n\n  private streams: { [id: string]: DefaultStream } = {}\n\n  constructor(socket: Socket, autoRestartStreamsOnReconnect: boolean) {\n    this.socket = socket\n    this.autoRestartStreamsOnReconnect = autoRestartStreamsOnReconnect\n  }\n\n  public release(): void {\n    this.debug(\"Releasing default stream client\")\n    this.socket.disconnect().catch((error) => {\n      this.debug(\n        \"An error occurred while disconnecting from socket while releasing instance\",\n        error\n      )\n    })\n  }\n\n  public setApiToken(apiToken: string) {\n    this.socket.setApiToken(apiToken)\n  }\n\n  public async registerStream(\n    message: OutboundMessage,\n    onMessage: OnStreamMessage\n  ): Promise<Stream> {\n    if (!this.socket.isConnected) {\n      this.debug(\"Socket is not connected, connecting socket first.\")\n      await this.socket.connect(this.handleMessage, { onReconnect: this.handleReconnection })\n    }\n\n    const id = message.req_id\n    if (this.streams[id] !== undefined) {\n      throw new DfuseClientError(\n        `A stream with id '${id}' is already registered, cannot register another one with the same id`\n      )\n    }\n\n    this.debug(\"Registering stream [%s] with message %o.\", id, message)\n    const streamExists = (streamId: string) => this.streams[streamId] !== undefined\n    const unregisterStream = (streamId: string) => this.unregisterStream(streamId)\n    const stream = new DefaultStream(\n      id,\n      message,\n      onMessage,\n      streamExists,\n      unregisterStream,\n      this.socket,\n      this.debug.extend(id, \":\")\n    )\n\n    // Let's first register stream to ensure that if messages arrives before we got back\n    // execution flow after `send` call, the listener is already present to handle message\n    this.streams[id] = stream\n\n    try {\n      await stream.start()\n    } catch (error) {\n      delete this.streams[id]\n      throw new DfuseClientError(`Unable to correctly register stream '${id}'`, error)\n    }\n\n    this.debug(\"Stream [%s] registered with remote endpoint.\", id)\n    return stream\n  }\n\n  public async unregisterStream(id: string): Promise<void> {\n    if (this.streams[id] === undefined) {\n      this.debug(\"Stream [%s] is already unregistered, nothing to do.\", id)\n      return\n    }\n\n    const message = unlistenMessage({ req_id: id })\n    this.debug(\"Unregistering stream [%s] with message %o.\", id, message)\n\n    delete this.streams[id]\n\n    if (this.socket.isConnected) {\n      await this.socket.send(message)\n    }\n\n    if (Object.keys(this.streams).length <= 0) {\n      this.debug(\"No more stream present, disconnecting socket.\")\n      if (this.socket.isConnected) {\n        await this.socket.disconnect()\n      }\n    }\n  }\n\n  private handleMessage = (rawMessage: unknown) => {\n    const message = rawMessage as InboundMessage\n\n    if (message.type === \"ping\") {\n      this.debug(\"Discarding 'ping' message from reaching the underlying stream(s).\")\n      return\n    }\n\n    let debug = this.debugTrace\n    if (\n      message.type === InboundMessageType.ERROR ||\n      message.type === InboundMessageType.LISTENING ||\n      message.type === InboundMessageType.UNLISTENED\n    ) {\n      debug = this.debug\n    }\n\n    debug(\n      \"Routing socket message of type '%s' with req_id '%s' to appropriate stream\",\n      message.type,\n      message.req_id\n    )\n    const stream = this.streams[message.req_id || \"\"]\n    if (stream === undefined) {\n      this.debug(\n        \"No stream currently registered able to handle message with req_id '%s'\",\n        message.req_id\n      )\n      return\n    }\n\n    stream.onMessage(message, stream)\n  }\n\n  private handleReconnection = () => {\n    if (this.autoRestartStreamsOnReconnect === false) {\n      return\n    }\n\n    Object.keys(this.streams).forEach((streamId) => {\n      this.streams[streamId].restart()\n    })\n  }\n}\n\nclass DefaultStream implements Stream {\n  public readonly id: string\n  public onPostRestart?: OnStreamRestart\n\n  private activeMarker?: StreamMarker\n  private activeJoiner?: Deferred<void>\n  private registrationMessage: OutboundMessage\n  private onMessageHandler: OnStreamMessage\n  private unregisterStream: (id: string) => Promise<void>\n  private streamExists: (id: string) => boolean\n  private socket: Socket\n  private debug: IDebugger\n\n  constructor(\n    id: string,\n    registrationMessage: OutboundMessage,\n    onMessage: OnStreamMessage,\n    streamExists: (id: string) => boolean,\n    unregisterStream: (id: string) => Promise<void>,\n    socket: Socket,\n    debug: IDebugger\n  ) {\n    this.id = id\n    this.registrationMessage = registrationMessage\n    this.onMessageHandler = onMessage\n    this.streamExists = streamExists\n    this.unregisterStream = unregisterStream\n    this.socket = socket\n    this.debug = debug\n  }\n\n  public get onMessage(): OnStreamMessage {\n    return this.onMessageHandler\n  }\n\n  public currentActiveMarker(): StreamMarker | undefined {\n    return this.activeMarker\n  }\n\n  public async start(): Promise<void> {\n    return this.socket.send(this.registrationMessage)\n  }\n\n  public async restart(marker?: StreamMarker): Promise<void> {\n    this.checkMarker(marker)\n\n    if (!this.streamExists(this.id)) {\n      throw new DfuseClientError(\n        `Trying to restart a stream '${\n          this.id\n        }' that is not registered anymore or was never registered`\n      )\n    }\n\n    let activeMarker = this.activeMarker\n    if (marker) {\n      activeMarker = marker\n    }\n\n    const restartMessage = { ...this.registrationMessage }\n    if (activeMarker) {\n      restartMessage.start_block = (activeMarker as any).atBlockNum\n    }\n\n    await this.socket.send(restartMessage)\n\n    if (this.onPostRestart) {\n      this.onPostRestart()\n    }\n  }\n\n  public async join(): Promise<void> {\n    if (this.activeJoiner !== undefined) {\n      return this.activeJoiner.promise()\n    }\n\n    this.activeJoiner = new Deferred()\n\n    return this.activeJoiner.promise()\n  }\n\n  public mark(marker: StreamMarker) {\n    this.activeMarker = this.checkMarker(marker)\n  }\n\n  public async close(options: { error?: Error } = {}): Promise<void> {\n    return (\n      this.unregisterStream(this.id)\n        .then(() => {\n          if (options.error) {\n            this.reject(options.error)\n          } else {\n            this.resolve()\n          }\n        })\n        // FIXME: We should probably return a MultiError of some kind to report both error if `options.error` exists\n        .catch(this.reject)\n    )\n  }\n\n  private checkMarker(marker?: StreamMarker): StreamMarker | undefined {\n    if (!marker) {\n      return undefined\n    }\n\n    if (!(marker as any).atBlockNum || (marker as any).atBlockNum < 0) {\n      throw new DfuseClientError(\n        \"Only non-zero & positive `atBlockNum` markers are accepted for this operation\"\n      )\n    }\n\n    return marker\n  }\n\n  private resolve = () => {\n    if (this.activeJoiner) {\n      this.debug(\"Resolving joiner promise.\")\n      this.activeJoiner.resolve()\n      this.activeJoiner = undefined\n    }\n  }\n\n  private reject = (error: Error) => {\n    if (this.activeJoiner) {\n      this.debug(\"Rejecting joiner promise with error %o.\", error)\n      this.activeJoiner.reject(error)\n      this.activeJoiner = undefined\n    }\n  }\n}\n","export function waitFor(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms))\n}\n","import debugFactory, { IDebugger } from \"debug\"\nimport { SocketOptions, createSocket } from \"./socket\"\nimport { Deferred } from \"../helpers/promises\"\nimport { DfuseClientError } from \"../types/error\"\nimport { Socket } from \"../types/socket\"\nimport { Stream, StreamMarker } from \"../types/stream\"\nimport {\n  GraphqlStreamClient,\n  OnGraphqlStreamMessage,\n  OnGraphqlStreamRestart\n} from \"../types/graphql-stream-client\"\nimport {\n  GraphqlDocument,\n  GraphqlVariables,\n  GraphqlInboundMessage,\n  GraphqlStartOutboundMessage\n} from \"../types/graphql\"\nimport { waitFor } from \"../helpers/time\"\n\nexport const DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS = 2500 // 2.5s\n\n/**\n * The set of options that can be used when constructing a the default\n * [[StreamClient]] instance through the [[createStreamClient]] factory\n * method.\n */\nexport interface GraphqlStreamClientOptions {\n  /**\n   * The [[Socket]] instance to use, inferred based on the environment when not provided.\n   *\n   * @default `undefined` (Inferred based on runtime environment (Node.js/Browser), see [[createSocket]])\n   */\n  socket?: Socket\n\n  /**\n   * The [[SocketOptions]] to pass when creating the default [[Socket]] instance.\n   * This field has no effect if you provide yourself a [[StreamClientOptions.socket]] option.\n   *\n   * @default `undefined` (See [[SocketOptions]] for actual defaults this generates)\n   */\n  socketOptions?: SocketOptions\n\n  /**\n   * Determines if all streams should automatically restart when the socket disconnects. The stream\n   * will re-connect at their latest marked value (See [[Stream.mark]]) if present or at current\n   * block if it was never marked.\n   *\n   * @default `true`\n   */\n  autoRestartStreamsOnReconnect?: boolean\n\n  /**\n   * Determines if all streams should automatically restart when the stream receives an `error`\n   * message type from the server. The stream will try to restart automatically at their latest\n   * marked value (See [[Stream.mark]]) if present or at current block if it was never marked.\n   *\n   * @default `true`\n   */\n  autoRestartStreamsOnError?: boolean\n\n  /**\n   * The delay after the the stream receives an error message to wait for before restarting\n   * the stream. As no effect if [[GraphqlStreamClientOptions.autoRestartStreamsOnError]] is sets\n   * to `false`.\n   *\n   * @default `2.5s` (See [[DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS]])\n   */\n  restartOnErrorDelayInMs?: number\n\n  /**\n   * When sets to `true`, when no more streams are active, the socket is\n   * automatically disconnected and closde. This option should be set to\n   * `false` when using `Query` or `Mutation` over WebSocket transport\n   * to avoid opening/closing the WebSocket connection for each operation\n   * or when multiple short lived `Subscription`s are used.\n   *\n   * @default `true`\n   */\n  autoDisconnectSocket?: boolean\n}\n\n/**\n * Create the default [[StreamClient]] concrete implementation.\n *\n * @param wsUrl The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter. Passed as\n * is to created [[Socket]] interface through the [[createSocket]] factory method. This parameter has no effect\n * if [[StreamClientOptions.socket]] options is used.\n * @param options The set of options used to construct the default [[StreamClient]] instance. See\n * [[StreamClientOptions]] for documentation of the options and default values for each of them.\n */\nexport function createGraphqlStreamClient(\n  wsUrl: string,\n  options: GraphqlStreamClientOptions = {}\n): GraphqlStreamClient {\n  return new DefaultGrahqlStreamClient(\n    options.socket ||\n      createSocket(wsUrl, {\n        id: \"graphql\",\n        webSocketProtocols: \"graphql-ws\",\n        ...options.socketOptions\n      }),\n    options.autoRestartStreamsOnReconnect === undefined\n      ? true\n      : options.autoRestartStreamsOnReconnect,\n    options.autoRestartStreamsOnError === undefined ? true : options.autoRestartStreamsOnError,\n    options.restartOnErrorDelayInMs === undefined\n      ? DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS\n      : options.restartOnErrorDelayInMs,\n    options.autoDisconnectSocket === undefined ? true : options.autoDisconnectSocket\n  )\n}\n\nclass DefaultGrahqlStreamClient {\n  private socket: Socket\n  private autoRestartStreamsOnReconnect: boolean\n  private autoRestartStreamsOnError: boolean\n  private restartOnErrorDelayInMs: number\n  private autoDisconnectSocket: boolean\n  private debug: IDebugger = debugFactory(\"dfuse:graphql-stream\")\n  private debugTrace: IDebugger = debugFactory(\"dfuse-trace:graphql-stream\")\n\n  private apiToken?: string\n  private connectionEstablisher: GraphqlConnectionEstablisher\n  private streams: { [id: string]: DefaultGraphqlStream<any> } = {}\n\n  constructor(\n    socket: Socket,\n    autoRestartStreamsOnReconnect: boolean,\n    autoRestartStreamsOnError: boolean,\n    restartOnErrorDelayInMs: number,\n    autoDisconnectSocket: boolean\n  ) {\n    this.socket = socket\n    this.autoRestartStreamsOnReconnect = autoRestartStreamsOnReconnect\n    this.autoRestartStreamsOnError = autoRestartStreamsOnError\n    this.restartOnErrorDelayInMs = restartOnErrorDelayInMs\n    this.autoDisconnectSocket = autoDisconnectSocket\n\n    this.connectionEstablisher = new GraphqlConnectionEstablisher(this.debug)\n  }\n\n  public release(): void {\n    this.debug(\"Terminating connection & releasing default GraphQL stream client\")\n\n    this.socket.disconnect().catch((error) => {\n      this.debug(\n        \"An error occurred while disconnecting from socket while releasing instance\",\n        error\n      )\n    })\n  }\n\n  public setApiToken(apiToken: string) {\n    this.apiToken = apiToken\n  }\n\n  public async registerStream<T = unknown>(\n    id: string,\n    document: GraphqlDocument,\n    variables: GraphqlVariables,\n    onMessage: OnGraphqlStreamMessage<T>\n  ): Promise<Stream> {\n    if (!this.socket.isConnected) {\n      this.debug(\"Socket is not connected, connecting socket first.\")\n      await this.socket.connect(this.handleMessage, { onReconnect: this.handleReconnection })\n      await this.connectionEstablisher.establish(this.apiToken!, this.socket)\n    }\n\n    if (this.streams[id] !== undefined) {\n      throw new DfuseClientError(\n        `A stream with id '${id}' is already registered, cannot register another one with the same id`\n      )\n    }\n\n    this.debug(\"Registering stream [%s]\", id)\n    const streamExists = (streamId: string) => this.streams[streamId] !== undefined\n    const unregisterStream = (streamId: string) => this.unregisterStream(streamId)\n    const stream = new DefaultGraphqlStream(\n      id,\n      document,\n      variables,\n      onMessage,\n      streamExists,\n      unregisterStream,\n      this.socket,\n      this.debug\n    )\n\n    // Let's first register stream to ensure that if messages arrives before we got back\n    // execution flow after `send` call, the listener is already present to handle message\n    this.streams[id] = stream\n\n    try {\n      await stream.start()\n    } catch (error) {\n      delete this.streams[id]\n      throw new DfuseClientError(`Unable to correctly register stream '${id}'`, error)\n    }\n\n    this.debug(\"Stream [%s] registered with remote endpoint.\", id)\n    return stream\n  }\n\n  public async unregisterStream(id: string): Promise<void> {\n    const stream = this.streams[id]\n    if (stream === undefined) {\n      this.debug(\"Stream [%s] is already unregistered, nothing to do.\", id)\n      return\n    }\n\n    this.debug(\"Unregistering stream [%s].\", id)\n    delete this.streams[id]\n\n    try {\n      if (stream.isActive && this.socket.isConnected) {\n        await this.socket.send({ id, type: \"stop\" })\n      }\n\n      if (Object.keys(this.streams).length <= 0 && this.autoDisconnectSocket) {\n        this.debug(\n          \"No more stream present and auto disconnect sets to true, terminating connection & disconnecting socket.\"\n        )\n        if (this.socket.isConnected) {\n          await this.socket.disconnect()\n        }\n      }\n\n      stream.onUnregister()\n    } catch (error) {\n      stream.onUnregister(error)\n      throw error\n    }\n  }\n\n  private handleMessage = async (rawMessage: unknown) => {\n    const message = rawMessage as GraphqlInboundMessage\n    if (message.type === \"ka\") {\n      this.debug(\"Discarding 'ka' (Keep Alive) message from reaching the underlying stream(s).\")\n      return\n    }\n\n    if (message.type === \"connection_ack\" || message.type === \"connection_error\") {\n      this.connectionEstablisher.onMessage(message)\n      return\n    }\n\n    let debug = this.debug\n    if (message.type === \"data\") {\n      debug = this.debugTrace\n    }\n\n    debug(\n      \"Routing socket message of type '%s' with id '%s' to appropriate stream\",\n      message.type,\n      message.id\n    )\n    const stream = this.streams[message.id || \"\"]\n    if (stream === undefined) {\n      this.debug(\"No stream currently registered able to handle message with 'id: %s'\", message.id)\n      return\n    }\n\n    if (message.type === \"data\") {\n      if (message.payload.errors) {\n        stream.onMessage({ type: \"error\", errors: message.payload.errors, terminal: false }, stream)\n      } else {\n        stream.onMessage({ type: \"data\", data: message.payload.data }, stream)\n      }\n\n      // Let's not continue for a data message\n      return\n    }\n\n    const onStreamCloseError = (error: any) => {\n      // FIXME: We shall pass this error somewhere, to some kind of notifier or event\n      //        emitter but there is no such stuff right now.\n      this.debug(\n        \"Closing the stream [%s] (in response of GraphQL '%s' message) failed %O.\",\n        stream.id,\n        message.type,\n        error\n      )\n    }\n\n    if (message.type === \"error\") {\n      stream.onMessage({ type: \"error\", errors: [message.payload], terminal: true }, stream)\n\n      if (this.autoRestartStreamsOnError) {\n        this.debug(\n          \"Stream [%s] received error message and auto restart on error set, waiting [%d ms] before restarting\",\n          stream.id,\n          this.restartOnErrorDelayInMs\n        )\n        await waitFor(this.restartOnErrorDelayInMs)\n        await stream.restart().catch((error) => {\n          // Can only happen if the socket does not auto-reconnect and connection lost, in which, stream is screwed anyway\n          stream.close({ error }).catch(onStreamCloseError)\n        })\n\n        return\n      }\n\n      stream.isActive = false\n    }\n\n    if (message.type === \"complete\") {\n      stream.onMessage({ type: \"complete\" }, stream)\n      stream.isActive = false\n    }\n\n    this.debug(\"About to close stream [%s] due to GraphQL '%s' message.\", stream.id, message.type)\n    const closeError = message.type === \"error\" ? message.payload : undefined\n\n    stream.close({ error: closeError }).catch(onStreamCloseError)\n  }\n\n  private handleReconnection = () => {\n    this.debug(\"Handling re-connection notification from socket.\")\n    if (this.autoRestartStreamsOnReconnect === false) {\n      return\n    }\n\n    this.connectionEstablisher\n      .establish(this.apiToken!, this.socket)\n      .then(() => {\n        return Promise.all(Object.keys(this.streams).map((id) => this.streams[id].restart()))\n      })\n      .catch(async (error) => {\n        const finalizer = () => {\n          // FIXME: We shall pass this error somewhere, to some kind of notifier or event\n          //        emitter but there is no such stuff right now.\n          this.debug(\"The re-connection failed to re-establish the GraphQL connection %O\", error)\n        }\n\n        return Promise.all(Object.keys(this.streams).map((id) => this.streams[id].close({ error })))\n          .then(finalizer)\n          .catch(finalizer)\n      })\n  }\n}\n\nclass DefaultGraphqlStream<T = unknown> implements Stream {\n  public readonly id: string\n  public onPostRestart?: OnGraphqlStreamRestart\n\n  private active: boolean\n  private activeMarker?: StreamMarker\n  private activeJoiner?: Deferred<void>\n  private closeError?: Error\n  private registrationDocument: GraphqlDocument\n  private registrationVariables: GraphqlVariables | (() => GraphqlVariables) | undefined\n  private onMessageHandler: OnGraphqlStreamMessage<T>\n  private unregisterStream: (id: string) => Promise<void>\n  private streamExists: (id: string) => boolean\n  private socket: Socket\n  private debug: IDebugger\n\n  constructor(\n    id: string,\n    registrationDocument: GraphqlDocument,\n    registrationVariables: GraphqlVariables,\n    onMessage: OnGraphqlStreamMessage<T>,\n    streamExists: (id: string) => boolean,\n    unregisterStream: (id: string) => Promise<void>,\n    socket: Socket,\n    debug: IDebugger\n  ) {\n    this.id = id\n    this.active = false\n    this.registrationDocument = registrationDocument\n    this.registrationVariables = registrationVariables\n    this.onMessageHandler = onMessage\n    this.streamExists = streamExists\n    this.unregisterStream = unregisterStream\n    this.socket = socket\n    this.debug = debug\n  }\n\n  public get isActive(): boolean {\n    return this.active\n  }\n\n  public set isActive(value: boolean) {\n    this.active = value\n  }\n\n  public get onMessage(): OnGraphqlStreamMessage<T> {\n    return this.onMessageHandler\n  }\n\n  public currentActiveMarker(): undefined | StreamMarker {\n    return this.activeMarker\n  }\n\n  public async start(): Promise<void> {\n    const message = await this.createStartMessage()\n    if (message.payload!.variables !== undefined) {\n      message.payload!.variables = {\n        cursor: \"\",\n        ...message.payload!.variables\n      }\n    }\n\n    return this.socket.send(message).then(() => {\n      this.active = true\n    })\n  }\n\n  public async restart(marker?: StreamMarker): Promise<void> {\n    this.debug(\"About to restart stream [%s]\", this.id)\n    this.checkMarker(marker)\n\n    if (!this.streamExists(this.id)) {\n      throw new DfuseClientError(\n        `Trying to restart a stream '${\n          this.id\n        }' that is not registered anymore or was never registered`\n      )\n    }\n\n    let activeMarker = this.activeMarker\n    if (marker) {\n      activeMarker = marker\n    }\n\n    const message = await this.createStartMessage()\n    if (activeMarker) {\n      message.payload.variables = {\n        ...(message.payload.variables || {}),\n        // @ts-ignore The `cursor` field is the only possibility here, it's just TypeScript can't discriminate it\n        cursor: activeMarker.cursor\n      }\n    }\n\n    await this.socket.send(message).then(() => {\n      this.active = true\n    })\n\n    if (this.onPostRestart) {\n      this.onPostRestart()\n    }\n  }\n\n  private async createStartMessage(): Promise<GraphqlStartOutboundMessage> {\n    let resolvedVariables = this.registrationVariables\n    if (typeof resolvedVariables === \"function\") {\n      // We use `as any` here because the docs builder which uses TypeScript 3.2.4 chokes on this line due to hard typing.\n      // At some point, the `typedoc` will be updated and the error should resolves itself. Simply remove the cast and\n      // regenerate the docs `yarn build:docs` to test if it's fixed or not.\n      resolvedVariables = await (resolvedVariables as any)()\n    }\n\n    return {\n      id: this.id,\n      type: \"start\",\n      payload: {\n        query: this.registrationDocument,\n        variables: {\n          cursor: \"\",\n          ...((resolvedVariables as (Record<string, unknown> | undefined)) || {})\n        }\n      }\n    }\n  }\n\n  public async join(): Promise<void> {\n    if (this.activeJoiner !== undefined) {\n      return this.activeJoiner.promise()\n    }\n\n    this.activeJoiner = new Deferred()\n\n    return this.activeJoiner.promise()\n  }\n\n  public mark(marker: StreamMarker) {\n    this.activeMarker = this.checkMarker(marker)\n  }\n\n  public async close(options: { error?: Error } = {}): Promise<void> {\n    this.closeError = options.error\n\n    return await this.unregisterStream(this.id)\n  }\n\n  private checkMarker(marker?: StreamMarker): StreamMarker | undefined {\n    if (!marker) {\n      return undefined\n    }\n\n    if (!(marker as any).cursor) {\n      throw new DfuseClientError(\"Only non-empty `cursor` markers are accepted for this operation\")\n    }\n\n    return marker\n  }\n\n  // Public only for the stream client to be able to call us directly. Not best practice but since\n  // the client and his streams are tighly coupled, cohesion makes sense here. Will never be seen\n  // by a consumer anyway and this method is not part of any backward compatibility policy.\n  public onUnregister(unregisterError?: Error) {\n    // FIXME: We should probably return a MultiError of some kind to report both of\n    //        `unregisterError` and `this.closeError` if they are both set.\n\n    if (unregisterError) {\n      this.reject(unregisterError)\n    } else if (this.closeError) {\n      this.reject(this.closeError)\n    } else {\n      this.resolve()\n    }\n  }\n\n  private resolve = () => {\n    if (this.activeJoiner) {\n      this.debug(\"Resolving joiner promise for stream [%s].\", this.id)\n      this.activeJoiner.resolve()\n    }\n  }\n\n  private reject = (error: Error) => {\n    if (this.activeJoiner) {\n      this.debug(\"Rejecting joiner promise for stream [%s] with error %o.\", this.id, error)\n      this.activeJoiner.reject(error)\n    }\n  }\n}\n\nclass GraphqlConnectionEstablisher {\n  private debug: IDebugger\n\n  private activeSocket?: Socket\n  private activeDeferred?: Deferred<void>\n\n  constructor(debug: IDebugger) {\n    this.debug = debug\n  }\n\n  public async establish(apiToken: string, socket: Socket): Promise<void> {\n    if (this.activeDeferred !== undefined) {\n      return this.activeDeferred.promise()\n    }\n\n    this.activeDeferred = new Deferred<void>()\n    this.activeSocket = socket\n\n    this.debug(\"Initiating graphql stream connection\")\n    socket.send({\n      type: \"connection_init\",\n      payload: {\n        Authorization: apiToken\n      }\n    })\n\n    return this.activeDeferred.promise()\n  }\n\n  public onMessage(message: GraphqlInboundMessage) {\n    if (this.activeDeferred === undefined) {\n      return\n    }\n\n    if (message.type === \"connection_ack\") {\n      this.debug(\"Received connection_ack message, resolving active promise\")\n      this.resolve()\n      return\n    }\n\n    if (message.type === \"connection_error\") {\n      this.debug(\"Received connection_error message %O, rejecting active promise\", message.payload)\n      this.reject(message.payload! as Error)\n      return\n    }\n\n    this.debug(\n      \"Received an unknown message while waiting for graphql connection to establish, something is fishy %O\",\n      message\n    )\n  }\n\n  private resolve() {\n    if (this.activeDeferred === undefined) {\n      return\n    }\n\n    this.debug(\"Resolving connection establisher deferred promise.\")\n    this.activeDeferred.resolve()\n    this.activeDeferred = undefined\n  }\n\n  private reject(error: Error) {\n    const complete = () => {\n      if (this.activeDeferred !== undefined) {\n        this.debug(\"Rejecting connection establisher deferred promise.\")\n        this.activeDeferred.reject(error)\n        this.activeDeferred = undefined\n      }\n    }\n\n    if (this.activeSocket && this.activeSocket.isConnected) {\n      this.activeSocket\n        .disconnect()\n        .then(complete)\n        .catch(complete)\n    } else {\n      complete()\n    }\n  }\n}\n","import { IDebugger } from \"debug\"\nimport debugFactory from \"debug\"\n\nexport type ScheduleJob = () => void\n\nexport interface RefreshScheduler {\n  release(): void\n  hasScheduledJob(): boolean\n  schedule(delayInSeconds: number, job: ScheduleJob): void\n}\n\nexport function createRefreshScheduler(): RefreshScheduler {\n  return new DefaultRefreshScheduler()\n}\n\nclass DefaultRefreshScheduler {\n  public renewalTimeout?: any\n  private debug: IDebugger\n\n  constructor() {\n    this.debug = debugFactory(\"dfuse:refresh-scheduler\")\n  }\n\n  public release(): void {\n    this.debug(\"Releasing default refresh scheduler\")\n    if (this.renewalTimeout !== undefined) {\n      this.debug(\"Clearing refresh timeout interval\")\n      this.clearRefreshTimeout()\n    }\n  }\n\n  public hasScheduledJob(): boolean {\n    return this.renewalTimeout !== undefined\n  }\n\n  public schedule(delayInSeconds: number, job: ScheduleJob, onJobFailed?: (error: any) => void) {\n    if (delayInSeconds <= 0) {\n      this.debug(\"Delay in seconds should be greater than 0\")\n      return\n    }\n\n    if (this.renewalTimeout) {\n      this.debug(\"Clearing previous sheduled timer\")\n      this.clearRefreshTimeout()\n    }\n\n    this.renewalTimeout = setTimeout(() => {\n      try {\n        this.debug(\"Executing scheduled job at %s%O\", new Date(), job)\n        job()\n      } catch (error) {\n        this.debug(\"Scheduled job failed (%o)\", error)\n        if (onJobFailed) {\n          onJobFailed(error)\n        }\n      }\n\n      this.clearRefreshTimeout()\n    }, delayInSeconds * 1000)\n  }\n\n  private clearRefreshTimeout() {\n    clearTimeout(this.renewalTimeout)\n    this.renewalTimeout = undefined\n  }\n}\n","import debugFactory, { IDebugger } from \"debug\"\nimport {\n  GetActionTracesMessageData,\n  StreamOptions,\n  GetTableRowsMessageData,\n  GetTransactionLifecycleMessageData,\n  OutboundMessage,\n  OutboundMessageFactory,\n  createOutboundMessage,\n  OutboundMessageType\n} from \"../message/outbound\"\nimport { DfuseClient, RequestIdGenerator, DfuseClientEndpoints } from \"../types/client\"\nimport { SearchSortType, SearchTransactionsResponse } from \"../types/search\"\nimport { AuthTokenResponse, ApiTokenInfo } from \"../types/auth-token\"\nimport {\n  StateAbiResponse,\n  StateKeyAccountsResponse,\n  StateAbiToJsonResponse,\n  StateTableScopesResponse,\n  StateKeyType,\n  StateResponse,\n  MultiStateResponse,\n  StatePermissionLinksResponse,\n  StateTableRowResponse\n} from \"../types/state\"\nimport {\n  ApiTokenManager,\n  createApiTokenManager,\n  createNoopApiTokenManager\n} from \"./api-token-manager\"\nimport { createHttpClient, HttpClientOptions } from \"./http-client\"\nimport {\n  V1_AUTH_ISSUE,\n  V0_SEARCH_TRANSACTIONS,\n  HttpQueryParameters,\n  V0_STATE_ABI,\n  V0_STATE_ABI_BIN_TO_JSON,\n  V0_STATE_KEY_ACCOUNTS,\n  V0_STATE_PERMISSION_LINKS,\n  V0_STATE_TABLE_SCOPES,\n  V0_STATE_TABLE,\n  V0_STATE_TABLES_ACCOUNTS,\n  V0_STATE_TABLES_SCOPES,\n  HttpClient,\n  HttpHeaders,\n  V0_FETCH_TRANSACTION,\n  V0_FETCH_BLOCK_ID_BY_TIME,\n  V0_STATE_TABLE_ROW\n} from \"../types/http-client\"\nimport { DfuseClientError, DfuseError } from \"../types/error\"\nimport { createStreamClient, StreamClientOptions } from \"./stream-client\"\nimport { createGraphqlStreamClient, GraphqlStreamClientOptions } from \"./graphql-stream-client\"\n\nimport { StreamClient, OnStreamMessage } from \"../types/stream-client\"\nimport {\n  ApiTokenStore,\n  InMemoryApiTokenStore,\n  LocalStorageApiTokenStore,\n  OnDiskApiTokenStore\n} from \"./api-token-store\"\nimport { RefreshScheduler, createRefreshScheduler } from \"./refresh-scheduler\"\nimport { Stream } from \"../types/stream\"\nimport { TransactionLifecycle } from \"../types/transaction\"\nimport { ComparisonOperator, BlockIdByTimeResponse } from \"../types/block-id\"\nimport { GraphqlStreamClient, OnGraphqlStreamMessage } from \"../types/graphql-stream-client\"\nimport {\n  GraphqlVariables,\n  GraphqlOperationType,\n  GraphqlDocument,\n  GraphqlResponse\n} from \"../types/graphql\"\n\nconst MAX_UINT32_INTEGER = 2147483647\n\n/**\n * All the options that can be pass to dfuse Client factory\n * [[createDfuseClient]].\n */\nexport interface DfuseClientOptions {\n  /**\n   * The network to connect to. Can be a plain string in the set\n   * `mainnet | jungle | kylin | worbli`. If it's not a string in this\n   * set, the value is assumed to be an hostname pointing to the\n   * the service, for example, your internal dfuse endpoint.\n   *\n   * When it's a known network name, the hostname that is used\n   * will be the known hostname for this network name.\n   *\n   * The final urls are constructed using\n   * the [[DfuseClientOptions.secure]] option to determine which\n   * protocol to use for HTTP (`https` or `http`) and WebSocket\n   * (`wss` or `ws`).\n   *\n   * @see https://docs.dfuse.io/#endpoints\n   */\n  network: \"mainnet\" | \"jungle\" | \"kylin\" | \"worbli\" | string\n\n  /**\n   * You dfuse API key to interact with the dfuse API service. You\n   * can obtain and manage your API keys at `https://app.dfuse.io`.\n   * This is the self-management portal where all information\n   * about your account can be found.\n   */\n  apiKey: string\n\n  /**\n   * Whether to use secure protocols or unsecure ones. This will\n   * control final URL constructed using this parameter value and\n   * the actual hostname as defined by the [[DfuseClientOptions.network]]\n   * value.\n   */\n  secure?: boolean\n\n  /**\n   * This is the authentication URL that will be reach to issue\n   * new API token.\n   *\n   * @default `https://auth.dfuse.io`\n   */\n  authUrl?: string\n\n  /**\n   * A function that generates a random request ID. This request ID\n   * is used when using the dfuse Stream API when no specific\n   * ID is passed at registration time.\n   *\n   * @default A generator that generates random id of the form `dc-<13-hex-chars>`.\n   */\n  requestIdGenerator?: RequestIdGenerator\n\n  /**\n   * The [[HttpClient]] instance that [[DfuseClient]] should use to interact\n   * with dfuse REST API. When `undefined` (the default), an instance is\n   * created using [[createHttpClient]] factory method and used. If\n   * [[DfuseClientOptions.httpClientOptions]] is set, it used when creating\n   * the default instanve.\n   *\n   * @default A default [[HttpClient]] instance (via [[createHttpClient]]) using [[DfuseClientOptions.httpClientOptions]].\n   */\n  httpClient?: HttpClient\n\n  /**\n   * The [[HttpClientOptions]] that should be used when creating the default\n   * instance of [[HttpClient]].\n   *\n   * This parameter has no effect at all if the [[DfuseClientOptions.httpClient]] is\n   * provided.\n   *\n   * @default `{}` See [[HttpClientOptions]] for default values\n   */\n  httpClientOptions?: HttpClientOptions\n\n  /**\n   * The [[StreamClient]] instance that [[DfuseClient]] should use to interact\n   * with dfuse Stream API. When `undefined` (the default), an instance is\n   * created using [[createStreamClient]] factory method and used. If\n   * [[DfuseClientOptions.streamClientOptions]] is set, it used when creating\n   * the default instanve.\n   *\n   * @default A default [[StreamClient]] instance (via [[createStreamClient]]) using [[DfuseClientOptions.streamClientOptions]].\n   */\n  streamClient?: StreamClient\n\n  /**\n   * The [[StreamClientOptions]] that should be used when creating the default\n   * instance of [[StreamClient]].\n   *\n   * This parameter has no effect at all if the [[DfuseClientOptions.streamClient]] is\n   * provided.\n   *\n   * @default `{}` See [[StreamClientOptions]] for default values\n   */\n  streamClientOptions?: StreamClientOptions\n\n  /**\n   * The [[GraphqlStreamClient]] instance that [[DfuseClient]] should use to interact\n   * with dfuse GraphQL Subscription API. When `undefined` (the default), an instance is\n   * created using [[createGraphqlStreamClient]] factory method and used. If\n   * [[DfuseClientOptions.graphqlStreamClientOptions]] is set, it used when creating\n   * the default instanve.\n   *\n   * @default A default [[GraphqlStreamClient]] instance (via [[createGraphqlStreamClient]]) using [[DfuseClientOptions.graphqlStreamClientOptions]].\n   */\n  graphqlStreamClient?: GraphqlStreamClient\n\n  /**\n   * The [[GraphqlStreamClientOptions]] that should be used when creating the default\n   * instance of [[GraphqlStreamClient]].\n   *\n   * This parameter has no effect at all if the [[DfuseClientOptions.graphqlStreamClient]] is\n   * provided.\n   *\n   * @default `{}` See [[GraphqlStreamClientOptions]] for default values\n   */\n  graphqlStreamClientOptions?: GraphqlStreamClientOptions\n\n  /**\n   * The API token store instance that should be use by the [[DfuseClient]]\n   * to retrieve and store the API token from. It's via this interface the\n   * API token is persisted and also retrieved from persistence storage\n   * when required.\n   *\n   * When `undefined` (the default), a [[LocalStorageApiTokenStore]] is\n   * used when a Browser environment is detected, a [[OnDiskApiTokenStore]] is\n   * used when a Node.js environment is detected and the [[InMemoryApiTokenStore]]\n   * is used as a fallback if niether detection worked.\n   *\n   * @default Inferred based on the environment (Browser [[LocalStorageApiTokenStore]], Node.js [[OnDiskApiTokenStore]], [[InMemoryApiTokenStore]] otherwise).\n   */\n  apiTokenStore?: ApiTokenStore\n\n  /**\n   * The refresh scheduler instance that should be used to schedule a token\n   * refresh. This is more an internal details of the [[DfuseClient]] should\n   * most likely `undefined` for most user to pick a default refresh scheduler.\n   *\n   * @default A default [[RefreshScheduler]] instance (via [[createRefreshScheduler]])\n   */\n  refreshScheduler?: RefreshScheduler\n}\n\n// Small module wide variable incremented each time a client instance is created\nlet clientInstanceId = 0\n\n/**\n * The main entry point of the library, use it to create the standard [[DfuseClient]]\n * instance.\n *\n * Only the `apiKey` and `network` parameters are mandatory, all others have sane\n * default values based on your execution environment (be it a Browser or Node.js).\n *\n * This will create the default\n *\n * @param options The options that can be passed to customize [[DfuseClient]] instance,\n * refer to the [[DfuseClientOptions]] for further details.\n *\n * @kind Factories\n */\nexport function createDfuseClient(options: DfuseClientOptions): DfuseClient {\n  checkApiKey(options.apiKey)\n\n  const endpoint = networkToEndpoint(options.network)\n  const secureEndpoint = options.secure === undefined ? true : options.secure\n\n  const authUrl = options.authUrl || \"https://auth.dfuse.io\"\n  const restUrl = secureEndpoint ? `https://${endpoint}` : `http://${endpoint}`\n  const websocketUrl = secureEndpoint ? `wss://${endpoint}` : `ws://${endpoint}`\n\n  const endpoints: DfuseClientEndpoints = {\n    authUrl,\n    graphqlQueryUrl: `${restUrl}/graphql`,\n    graphqlStreamUrl: `${websocketUrl}/graphql`,\n    restUrl,\n    websocketUrl\n  }\n\n  const httpClient =\n    options.httpClient || createHttpClient(authUrl, restUrl, options.httpClientOptions)\n  const streamClient =\n    options.streamClient ||\n    createStreamClient(websocketUrl + \"/v1/stream\", options.streamClientOptions)\n\n  const graphqlStreamClient =\n    options.graphqlStreamClient ||\n    createGraphqlStreamClient(endpoints.graphqlStreamUrl, options.graphqlStreamClientOptions)\n\n  const apiTokenStore = options.apiTokenStore || inferApiTokenStore(options.apiKey)\n  const refreshScheduler = options.refreshScheduler || createRefreshScheduler()\n\n  const requestIdGenerator = options.requestIdGenerator || randomReqId\n\n  return new DefaultClient(\n    clientInstanceId++,\n    options.apiKey,\n    endpoints,\n    httpClient,\n    streamClient,\n    graphqlStreamClient,\n    apiTokenStore,\n    refreshScheduler,\n    requestIdGenerator\n  )\n}\n\n// Even though higher the type say it cannot be empty, this is usually provided\n// by the user and as such, as assume it could be undefined.\nfunction checkApiKey(apiKey: string | undefined) {\n  if (apiKey == null) {\n    const messages = [\n      \"The client must be configured with an API key via the \",\n      \"`apiKey` config options.\",\n      \"\",\n      \"Received nothing.\"\n    ]\n\n    throw new DfuseError(messages.join(\"\\n\"))\n  }\n\n  if (!apiKey.match(/^(mobile|server|web)_[0-9a-f]{2,}/i)) {\n    const messages = [\n      \"The provided API key is not in the right format, expecting it\",\n      \"to start with either `mobile_`, `server_` or `web_` followed\",\n      \"by a series of hexadecimal character (i.e.) `web_0123456789abcdef`)\",\n      \"\"\n    ]\n\n    // Assume it's an API token if looks (roughly) like a JWT token\n    if (apiKey.split(\".\").length === 3) {\n      messages.push(\n        \"It seems your providing directly a API token (JWT) instead\",\n        \"of an API key and are using your previous authentication protocol.\",\n        \"Please refer to http://docs.dfuse.io/#authentication for\",\n        \"all the details about API key and how to generate an API token\",\n        \"from it.\",\n        \"\",\n        \"And you can visit https://app.dfuse.io to obtain your free API key\",\n        \"\"\n      )\n    }\n\n    messages.push(`Input received: ${apiKey}`)\n\n    throw new DfuseError(messages.join(\"\\n\"))\n  }\n}\n\nfunction inferApiTokenStore(apiKey: string) {\n  const debug = debugFactory(\"dfuse:client\")\n\n  debug(\"Inferring API token store default concrete implementation to use\")\n  if (typeof window !== \"undefined\" && window.localStorage != null) {\n    debug(\n      'Using `LocalStorageApiTokenStore` as we assumed a Browser environment (`typeof window.localStorage !== \"undefined\"`).'\n    )\n    return new LocalStorageApiTokenStore(\"dfuse:token\")\n  }\n\n  // Just in the sake that `window.localStorage` is not supported for whatever, fall\n  // back to Node.js default only if we are really in a Node.js like environment.\n  if (typeof window === \"undefined\") {\n    debug(\n      'Using `OnDiskLocalStorageApiTokenStore` as we assumed a Node.js enviroment (`typeof window === \"undefined\"`).'\n    )\n    return new OnDiskApiTokenStore(apiKey)\n  }\n\n  debug(\"Falling back default `InMemoryApiTokenStore` concrete implementation\")\n  return new InMemoryApiTokenStore()\n}\n\nexport function networkToEndpoint(network: string): string {\n  if (\n    network === \"mainnet\" ||\n    network === \"jungle\" ||\n    network === \"kylin\" ||\n    network === \"worbli\"\n  ) {\n    return `${network}.eos.dfuse.io`\n  }\n\n  // Network is assumed to be an hostname to reach the dfuse service\n  return network\n}\n\n/**\n * The standard implementation of a [[DfuseClient]].\n *\n * The [[DefaultClient]] role is to perform the API key management\n * functionalities of the client. It retrieves an API token using the\n * API key and ensures it stays valid throughout the lifecycle of the\n * client, refreshing the token when necessary.\n *\n * It also responsible of keep and up-to-date list of streams and managing\n * the re-connection to those stream when the websocket disconnects.\n *\n * It is supported to override the client to provide some other\n * methods on it (other EOS endpoints).\n */\nexport class DefaultClient implements DfuseClient {\n  public readonly endpoints: DfuseClientEndpoints\n\n  protected id: number\n  protected apiKey: string\n  protected apiTokenManager: ApiTokenManager\n  protected httpClient: HttpClient\n  protected streamClient: StreamClient\n  protected graphqlStreamClient: GraphqlStreamClient\n  protected requestIdGenerator: RequestIdGenerator\n\n  protected debug: IDebugger = debugFactory(\"dfuse:client\")\n\n  constructor(\n    id: number,\n    apiKey: string,\n    endpoints: DfuseClientEndpoints,\n    httpClient: HttpClient,\n    streamClient: StreamClient,\n    graphqlStreamClient: GraphqlStreamClient,\n    apiTokenStore: ApiTokenStore,\n    refreshScheduler: RefreshScheduler,\n    requestIdGenerator: RequestIdGenerator\n  ) {\n    this.id = id\n    this.apiKey = apiKey\n    this.endpoints = endpoints\n    this.httpClient = httpClient\n    this.streamClient = streamClient\n    this.graphqlStreamClient = graphqlStreamClient\n    this.requestIdGenerator = requestIdGenerator\n\n    if (this.endpoints.authUrl.startsWith(\"null://\")) {\n      this.apiTokenManager = createNoopApiTokenManager(\"a.b.c\")\n    } else {\n      this.apiTokenManager = createApiTokenManager(\n        () => this.authIssue(this.apiKey),\n        this.onTokenRefresh,\n        0.95,\n        apiTokenStore,\n        refreshScheduler\n      )\n    }\n  }\n\n  public release(): void {\n    this.debug(\"Releasing default dfuse client\")\n    this.httpClient.release()\n    this.streamClient.release()\n    this.graphqlStreamClient.release()\n    this.apiTokenManager.release()\n  }\n\n  //\n  /// GraphQL API\n  //\n\n  // The return type has `Promise<GraphqlResponse<T> | Stream | any>`. The `any` sadly is an\n  // artefact to please the compiler. Without it, the compiler thinks the resulting type is\n  // not a proper implementation of `DfuseClient.graphql` which has two signatures, both of them\n  // being of a different return type.\n  public async graphql<T = any>(\n    document: string | GraphqlDocument,\n    onMessage?:\n      | OnGraphqlStreamMessage<T>\n      | {\n          variables?: GraphqlVariables\n          operationType?: Exclude<GraphqlOperationType, \"subscription\">\n        },\n    options: {\n      operationType?: GraphqlOperationType\n      variables?: GraphqlVariables\n    } = {}\n  ): Promise<GraphqlResponse<T> | Stream | any> {\n    if (typeof onMessage !== \"function\" && onMessage) {\n      options = onMessage\n    }\n\n    if (options.operationType && !isValidDocumentType(options.operationType)) {\n      throw new DfuseError(\n        `The 'options.operationType' value '${\n          options.operationType\n        }' is invalid, it must be either 'query', 'mutation' or 'subscription').`\n      )\n    }\n\n    // If an `onMessage` options is provided, always use the WebSocket connection\n    const onMessageProvided = typeof onMessage === \"function\" && onMessage\n    if (onMessageProvided) {\n      return this.withApiToken((apiTokenInfo: ApiTokenInfo) => {\n        this.graphqlStreamClient.setApiToken(apiTokenInfo.token)\n\n        return this.graphqlStreamClient.registerStream(\n          `${this.requestIdGenerator()}-${this.id}`,\n          // FIXME: Turn the document if a GraphQL document into a proper document string\n          document,\n          options.variables,\n          onMessage as OnGraphqlStreamMessage<T>\n        )\n      })\n    }\n\n    const operationType = this.inferOperationType(document, options.operationType)\n    if (!operationType && !onMessageProvided) {\n      const messages = [\n        \"We were not able to infer the GraphQL operation type you are trying to perform from\",\n        \"the document and options you provided. Without the document's operation type, we are\",\n        \"unable to determine the transport layer to use to execute your operation, either HTTP\",\n        \"or WebSocket transport.\",\n        \"\",\n        \"If you passed a document as a plain 'string' value, please use the `options.operationType`\",\n        \"option to provide the operation type to perform. You can also use the 'gql' string literal\",\n        \"processor to turn your string into a rich Document, on which inference always work.\",\n        \"\",\n        \"If you already provided the document a rich Document format via the 'gql` ...`' call, then it's\",\n        \"probably a bug in this library. You can provide the `options.operationType` option to workaround\",\n        \"the problem and report the bug to us with the document string used.\",\n        \"\",\n        \"Valid `options.operationType` values are either 'query', 'mutation' or 'subscription'.\",\n        \"\",\n        \"You can also force usage of WebSocket transport by providing the `options.onMessage` which\",\n        \"forces the usage of the WebSocket transport.\"\n      ]\n\n      throw new DfuseError(messages.join(\"\\n\"))\n    }\n\n    if (operationType === \"subscription\" && !onMessageProvided) {\n      const messages = [\n        \"The `options.onMessage` parameter is required for 'subscription' document.\",\n        \"If your document is not a 'subscription' type, this is probably a bug with the library.\",\n        \"You can provide the `options.operationType` option to workaroundthe problem and report\",\n        \"the bug to us with the document string used.\"\n      ]\n\n      throw new DfuseError(messages.join(\"\\n\"))\n    }\n\n    // FIXME: Turn the document into a proper document string if a GraphQL document\n    return await this.apiRequest<GraphqlResponse<T>>(\n      \"/graphql\",\n      \"POST\",\n      {},\n      { query: document as string, variables: options.variables }\n    )\n  }\n\n  //\n  /// WebSocket API\n  //\n\n  public streamActionTraces(\n    data: GetActionTracesMessageData,\n    onMessage: OnStreamMessage,\n    options: StreamOptions = {}\n  ): Promise<Stream> {\n    return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) =>\n      messageCreator(\n        OutboundMessageType.GET_ACTION_TRACES,\n        data,\n        withDefaultOptions({ listen: true, ...options })\n      )\n    )\n  }\n\n  public async streamTableRows(\n    data: GetTableRowsMessageData,\n    onMessage: OnStreamMessage,\n    options: StreamOptions = {}\n  ): Promise<Stream> {\n    return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) =>\n      messageCreator(\n        OutboundMessageType.GET_TABLE_ROWS,\n        { json: true, ...data },\n        withDefaultOptions({ listen: true, ...options })\n      )\n    )\n  }\n\n  public async streamTransaction(\n    data: GetTransactionLifecycleMessageData,\n    onMessage: OnStreamMessage,\n    options: StreamOptions = {}\n  ): Promise<Stream> {\n    return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) =>\n      messageCreator(\n        OutboundMessageType.GET_TRANSACTION_LIFECYCLE,\n        data,\n        withDefaultOptions({ listen: true, fetch: true, ...options })\n      )\n    )\n  }\n\n  public streamHeadInfo(onMessage: OnStreamMessage, options: StreamOptions = {}): Promise<Stream> {\n    return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => {\n      return messageCreator(\n        OutboundMessageType.GET_HEAD_INFO,\n        {},\n        withDefaultOptions({ listen: true, ...options })\n      )\n    })\n  }\n\n  public websocketStream<T>(\n    onMessage: OnStreamMessage,\n    initMessageFactory: OutboundMessageFactory<T>\n  ): Promise<Stream> {\n    const message = initMessageFactory(createOutboundMessage, this.withDefaultOptions)\n\n    return this.registerStream(message, onMessage)\n  }\n\n  private withDefaultOptions = (options: StreamOptions) => {\n    return { req_id: `${this.requestIdGenerator()}-${this.id}`, ...options }\n  }\n\n  //\n  /// HTTP API\n  //\n\n  public async authIssue(apiKey: string): Promise<AuthTokenResponse> {\n    return this.httpClient.authRequest<AuthTokenResponse>(V1_AUTH_ISSUE, \"POST\", undefined, {\n      api_key: apiKey\n    })\n  }\n\n  public async fetchBlockIdByTime(\n    time: string | Date,\n    comparator: ComparisonOperator\n  ): Promise<BlockIdByTimeResponse> {\n    let timeString = time\n    if (time instanceof Date) {\n      timeString = time.toISOString()\n    }\n\n    return this.apiRequest<BlockIdByTimeResponse>(V0_FETCH_BLOCK_ID_BY_TIME, \"GET\", {\n      time: timeString,\n      comparator\n    })\n  }\n\n  public fetchTransaction(id: string): Promise<TransactionLifecycle> {\n    // TODO: Should we properly URL encode the transaction id?\n    return this.apiRequest<TransactionLifecycle>(V0_FETCH_TRANSACTION.replace(\":id\", id), \"GET\")\n  }\n\n  public async searchTransactions(\n    q: string,\n    options: {\n      startBlock?: number\n      sort?: SearchSortType\n      blockCount?: number\n      limit?: number\n      cursor?: string\n      withReversible?: boolean\n    } = {}\n  ): Promise<SearchTransactionsResponse> {\n    return this.apiRequest<SearchTransactionsResponse>(V0_SEARCH_TRANSACTIONS, \"GET\", {\n      q,\n      start_block: options.startBlock,\n      sort: options.sort,\n      block_count: options.blockCount === undefined ? MAX_UINT32_INTEGER : options.blockCount,\n      limit: options.limit,\n      cursor: options.cursor,\n      with_reversible: options.withReversible\n    })\n  }\n\n  public async stateAbi(\n    account: string,\n    options: { blockNum?: number; json?: boolean } = {}\n  ): Promise<StateAbiResponse> {\n    return this.apiRequest<StateAbiResponse>(V0_STATE_ABI, \"GET\", {\n      account,\n      block_num: options.blockNum,\n      json: options.json === undefined ? true : options.json\n    })\n  }\n\n  public async stateAbiBinToJson<T = unknown>(\n    account: string,\n    table: string,\n    hexRows: string[],\n    options: { blockNum?: number } = {}\n  ): Promise<StateAbiToJsonResponse<T>> {\n    return this.apiRequest<StateAbiToJsonResponse<T>>(V0_STATE_ABI_BIN_TO_JSON, \"POST\", undefined, {\n      account,\n      table,\n      hex_rows: hexRows,\n      block_num: options.blockNum\n    })\n  }\n\n  public async stateKeyAccounts(\n    publicKey: string,\n    options: { blockNum?: number } = {}\n  ): Promise<StateKeyAccountsResponse> {\n    return this.apiRequest<StateKeyAccountsResponse>(V0_STATE_KEY_ACCOUNTS, \"GET\", {\n      public_key: publicKey,\n      block_num: options.blockNum\n    })\n  }\n\n  public async statePermissionLinks(\n    account: string,\n    options: { blockNum?: number } = {}\n  ): Promise<StatePermissionLinksResponse> {\n    return this.apiRequest<StatePermissionLinksResponse>(V0_STATE_PERMISSION_LINKS, \"GET\", {\n      account,\n      block_num: options.blockNum\n    })\n  }\n\n  public async stateTableScopes(\n    account: string,\n    table: string,\n    options: { blockNum?: number } = {}\n  ): Promise<StateTableScopesResponse> {\n    return this.apiRequest<StateTableScopesResponse>(V0_STATE_TABLE_SCOPES, \"GET\", {\n      account,\n      table,\n      block_num: options.blockNum\n    })\n  }\n\n  public async stateTable<T = unknown>(\n    account: string,\n    scope: string,\n    table: string,\n    options: {\n      blockNum?: number\n      json?: boolean\n      keyType?: StateKeyType\n      withBlockNum?: boolean\n      withAbi?: boolean\n    } = {}\n  ): Promise<StateResponse<T>> {\n    return this.apiRequest<StateResponse<T>>(V0_STATE_TABLE, \"GET\", {\n      account,\n      scope,\n      table,\n      block_num: options.blockNum,\n      json: options.json === undefined ? true : options.json,\n      key_type: options.keyType,\n      with_block_num: options.withBlockNum,\n      with_abi: options.withAbi\n    })\n  }\n\n  public async stateTableRow<T = unknown>(\n    account: string,\n    scope: string,\n    table: string,\n    primaryKey: string,\n    options: {\n      blockNum?: number\n      json?: boolean\n      keyType?: StateKeyType\n      withBlockNum?: boolean\n      withAbi?: boolean\n    } = {}\n  ): Promise<StateTableRowResponse<T>> {\n    return this.apiRequest<StateTableRowResponse<T>>(V0_STATE_TABLE_ROW, \"GET\", {\n      account,\n      scope,\n      table,\n      primary_key: primaryKey,\n      block_num: options.blockNum,\n      json: options.json === undefined ? true : options.json,\n      key_type: options.keyType,\n      with_block_num: options.withBlockNum,\n      with_abi: options.withAbi\n    })\n  }\n\n  public async stateTablesForAccounts<T = unknown>(\n    accounts: string[],\n    scope: string,\n    table: string,\n    options: {\n      blockNum?: number\n      json?: boolean\n      keyType?: StateKeyType\n      withBlockNum?: boolean\n      withAbi?: boolean\n    } = {}\n  ): Promise<MultiStateResponse<T>> {\n    return this.apiRequest<MultiStateResponse<T>>(\n      V0_STATE_TABLES_ACCOUNTS,\n      \"POST\",\n      undefined,\n      {\n        accounts: accounts.join(\"|\"),\n        scope,\n        table,\n        block_num: options.blockNum,\n        json: options.json === undefined ? true : options.json,\n        key_type: options.keyType,\n        with_block_num: options.withBlockNum,\n        with_abi: options.withAbi\n      },\n      {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      }\n    )\n  }\n\n  public async stateTablesForScopes<T = unknown>(\n    account: string,\n    scopes: string[],\n    table: string,\n    options: {\n      blockNum?: number\n      json?: boolean\n      keyType?: StateKeyType\n      withBlockNum?: boolean\n      withAbi?: boolean\n    } = {}\n  ): Promise<MultiStateResponse<T>> {\n    return this.apiRequest<MultiStateResponse<T>>(\n      V0_STATE_TABLES_SCOPES,\n      \"POST\",\n      undefined,\n      {\n        account,\n        scopes: scopes.join(\"|\"),\n        table,\n        block_num: options.blockNum,\n        json: options.json === undefined ? true : options.json,\n        key_type: options.keyType,\n        with_block_num: options.withBlockNum,\n        with_abi: options.withAbi\n      },\n      {\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      }\n    )\n  }\n\n  public async apiRequest<T>(\n    path: string,\n    method: string,\n    params?: HttpQueryParameters,\n    body?: any,\n    headers?: HttpHeaders\n  ): Promise<T> {\n    return this.withApiToken((apiTokenInfo: ApiTokenInfo) => {\n      return this.httpClient.apiRequest<T>(apiTokenInfo.token, path, method, params, body, headers)\n    })\n  }\n\n  public async getTokenInfo(): Promise<ApiTokenInfo> {\n    return this.apiTokenManager.getTokenInfo()\n  }\n\n  protected async registerStream(\n    message: OutboundMessage,\n    onMessage: OnStreamMessage\n  ): Promise<Stream> {\n    return this.withApiToken((apiTokenInfo: ApiTokenInfo) => {\n      this.streamClient.setApiToken(apiTokenInfo.token)\n\n      return this.streamClient.registerStream(message, onMessage)\n    })\n  }\n\n  private async withApiToken<R>(worker: (apiTokenInfo: ApiTokenInfo) => Promise<R>): Promise<R> {\n    let apiTokenInfo: ApiTokenInfo\n    try {\n      this.debug(\"Retrieving latest API token via token manager\")\n      apiTokenInfo = await this.apiTokenManager.getTokenInfo()\n    } catch (error) {\n      throw new DfuseClientError(\"Unable to obtain the API token\", error)\n    }\n\n    return await worker(apiTokenInfo)\n  }\n\n  private inferOperationType(\n    document: string | GraphqlDocument,\n    predefinedOperationType?: GraphqlOperationType\n  ): GraphqlOperationType | undefined {\n    this.debug(\n      \"Trying to infer operation type based on document and predefined operation type, predefined operation type '%s' and document %o\",\n      predefinedOperationType,\n      document\n    )\n    if (predefinedOperationType) {\n      this.debug(\"Predefined type '%s' provided, using it straight away.\", predefinedOperationType)\n      return predefinedOperationType\n    }\n\n    if (typeof document === \"string\") {\n      this.debug(\"Document is a plain string type, performing a poor-man Regex extraction.\")\n\n      const matches = document.match(\n        /^\\s*(query|mutation|subscription)?\\s*([_A-Za-z][_0-9A-Za-z]*\\s*)?(\\([^\\)]*\\)\\s*)?{/\n      )\n\n      if (matches == null) {\n        this.debug(\"Document string did not match our Regex, aborting inference.\")\n        return undefined\n      }\n      if (matches && matches[1]) {\n        this.debug(\"Document string Regex matches have operation type '%s', using it.\", matches[1])\n        return matches[1] as GraphqlOperationType\n      }\n\n      this.debug(\"Document string Regex matches but operation type was not present, using 'query'.\")\n      return \"query\"\n    }\n\n    // FIXME: Make the initial AST walking and work our way through!\n    return undefined\n  }\n\n  private onTokenRefresh = (apiToken: string) => {\n    // Ensure we update the API token to have it at its latest value\n    this.streamClient.setApiToken(apiToken)\n    this.graphqlStreamClient.setApiToken(apiToken)\n  }\n}\n\nfunction isValidDocumentType(type?: string): boolean {\n  if (!type) {\n    return false\n  }\n\n  return type === \"subscription\" || type === \"query\" || type === \"mutation\"\n}\n\nfunction randomReqId() {\n  return `dc-${Math.random()\n    .toString(16)\n    .substr(2)}`\n}\n","import { OnStreamMessage } from \"../types/stream-client\"\nimport { InboundMessage } from \"../message/inbound\"\nimport { Stream } from \"../types/stream\"\n\n/**\n * This small utility is useful to implement a dynamic dispatcher\n * based on the type of message. That is usefull to avoid having to\n * code yourself a `switch (message.type) { ... }` switch case.\n *\n * Instead, define a series of specific of handlers on a class or\n * an object, then when calling the stream method of your choices,\n * pass the dynamic dispatcher created by calling this method as\n * the message handler.\n *\n * The created dispatcher upon each message, will check the received\n * type to handler map and will dispatch it there.\n *\n * ```\n * const dispatch = dynamicMessageDispatcher({\n *   listening: this.onListening,\n *   progress: this.onProgress,\n *   action_trace: this.onAction,\n * })\n *\n * client.streamActionTraces({ ... }, dispatcher)\n * ```\n */\nexport function dynamicMessageDispatcher(typeToDispatcher: {\n  [messageType: string]: OnStreamMessage\n}): OnStreamMessage {\n  return (message: InboundMessage, stream: Stream) => {\n    const dispatcher = typeToDispatcher[message.type]\n    if (dispatcher) {\n      dispatcher(message, stream)\n    }\n  }\n}\n","import { TransactionLifecycle } from \"../types/transaction\"\nimport { ActionTrace } from \"../types/action-trace\"\nimport { SearchTransactionRow } from \"../types/search\"\n\ntype WalkActionsState = {\n  index: number\n  actions: ActionTrace<unknown>[]\n}\n\n/**\n * This method flattens the nested action traces of a [[TransactionLifecycle]] into\n * a single flat list. The flat list indexes matches dfuse API action index\n * which is used within dfuse to identify particular action trace in\n * various situation (db ops, RAM ops, etc).\n *\n * The action index of a given action is obtained simply by doing a\n * deep-first traversal of the action traces structure incrementing\n * a counter at each step and binding the counter to the current traversed\n * action becoming the action's index.\n *\n * As an example of this method, assume the following transaction:\n *\n * ```\n * Transaction 123 {\n *   ExecutionTrace {\n *     ActionTraces: [\n *       ActionTrace(eosio.token/eosio.token:transfer) {\n *         InlineTraces: [\n *           ActionTrace(from/eosio.token:transfer) {\n *             InlineTraces: [\n *               ActionTrace(contractX/contractX:log)\n *             ]\n *           }\n *           ActionTrace(to/eosio.token:transfer) {\n *             InlineTraces: [\n *               ActionTrace(contractY/contractY:update)\n *             ]\n *           }\n *         ]\n *       }\n *     ]\n *   }\n * }\n * ```\n *\n * This will results in the following flattened actions list being returned:\n *\n * ```\n * [\n *   ActionTrace(eosio.token/eosio.token:transfer),\n *   ActionTrace(from/eosio.token:transfer),\n *   ActionTrace(contractX/contractX:log),\n *   ActionTrace(to/eosio.token:transfer),\n *   ActionTrace(contractY/contractY:update),\n * ]\n * ```\n *\n * @param transaction The transaction lifecycle object to flatten action traces from.\n * @returns A flat list of action traces extracted from the transaction lifecycle for which each\n * index of the list represents the action's index concept of dfuse API.\n */\nexport function flattenActionTraces(transaction: TransactionLifecycle): ActionTrace<any>[] {\n  if (!transaction.execution_trace) {\n    return []\n  }\n\n  const state = {\n    index: -1,\n    actions: []\n  }\n\n  transaction.execution_trace.action_traces.forEach((actionTrace) => {\n    walkFlattenedActionTraces(actionTrace, state)\n  })\n\n  return state.actions\n}\n\nfunction walkFlattenedActionTraces(rootActionTrace: ActionTrace<any>, state: WalkActionsState) {\n  state.index++\n  state.actions.push(rootActionTrace)\n\n  const childActionTraces = rootActionTrace.inline_traces || []\n\n  childActionTraces.forEach((childActionTrace) => {\n    walkFlattenedActionTraces(childActionTrace, state)\n  })\n}\n\n/**\n * This method extracts the matchinf actions out of [[SearchTransactionRow]]\n * object.\n *\n * Using the search endpoint, you receives a [[SearchTransactionRow]] that\n * is simply a composite object containing an actual [[TransactionLifecycle]]\n * element as well as a list of action indexes which are the actual\n * ones that matched your query.\n *\n * A single transaction can contains a big amount of actions but usually,\n * only a subset of the actions in a transaction matches your search query.\n *\n * By using this method, you can easily extracts the matching actions\n * out of the [[SearchTransactionRow]] object.\n *\n * @param searchRow The search result row to extract matching action traces from.\n * @returns A flat list of action traces extracted from the search result row that matched\n * the query term(s).\n */\nexport function matchingActionTraces(searchRow: SearchTransactionRow): ActionTrace<any>[] {\n  if (!searchRow.lifecycle.execution_trace) {\n    return []\n  }\n\n  const matchingActionIndexes = searchRow.action_idx\n  const state = {\n    index: -1,\n    actions: []\n  }\n\n  searchRow.lifecycle.execution_trace.action_traces.forEach((actionTrace) => {\n    walkMatchingActionTraces(actionTrace, matchingActionIndexes, state)\n  })\n\n  return state.actions\n}\n\nfunction walkMatchingActionTraces(\n  rootActionTrace: ActionTrace<any>,\n  matchingActionIndexes: number[],\n  state: WalkActionsState\n) {\n  state.index++\n  if (matchingActionIndexes.includes(state.index)) {\n    state.actions.push(rootActionTrace)\n  }\n\n  const childActionTraces = rootActionTrace.inline_traces || []\n\n  childActionTraces.forEach((childActionTrace) => {\n    walkMatchingActionTraces(childActionTrace, matchingActionIndexes, state)\n  })\n}\n"],"names":["s","m","h","d","w","y","val","options","type","length","str","String","match","exec","n","parseFloat","toLowerCase","parse","isNaN","long","ms","msAbs","Math","abs","plural","fmtLong","round","fmtShort","Error","JSON","stringify","name","isPlural","env","selectColor","namespace","hash","i","charCodeAt","createDebug","colors","prevTime","debug","args","enabled","self","curr","Number","Date","diff","prev","coerce","unshift","index","replace","format","formatter","formatters","call","splice","formatArgs","log","apply","useColors","color","destroy","extend","init","instances","push","indexOf","this","delimiter","newDebug","toNamespace","regexp","toString","substring","default","stack","message","disable","namespaces","names","map","skips","join","enable","save","split","len","RegExp","substr","instance","test","humanize","require$$0","Object","keys","forEach","key","load","exports","console","module","c","lastC","storage","setItem","removeItem","error","r","getItem","process","DEBUG","window","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","$1","localStorage","localstorage","j","v","createApiTokenManager","fetchTokenInfo","onTokenRefresh","delayBuffer","apiTokenStore","refreshScheduler","DefaultApiTokenManager","createNoopApiTokenManager","token","NoopApiTokenManager","isApiTokenExpired","tokenInfo","now","expires_at","[object Object]","debugFactory","release","get","maybeScheduleNextRefresh","forceRefresh","Promise","resolve","refreshToken","internalFetchToken","set","hasScheduledJob","delayInSeconds","getRefreshDelayInSeconds","refreshAt","schedule","nowInSeconds","floor","undefined","fetchTokenPromise","reject","then","apiTokenInfo","catch","expiresAt","DfuseError","cause","super","description","DfuseApiError","data","code","trace_id","details","DfuseClientError","DfuseSocketError","OutboundMessageType","InMemoryApiTokenStore","LocalStorageApiTokenStore","raw","FileApiTokenStore","filePath","fs","existsSync","readFile","readData","mkdirpSync","directory","path","isAbsolute","parent","mkdirSync","dirname","writeFile","writeData","OnDiskApiTokenStore","apiKey","os","homedir","crypto","createHash","update","digest","unlistenMessage","req_id","UNLISTEN","createOutboundMessage","createHttpClient","authUrl","apiUrl","DefaultHttpClient","fetch","bind","global","inferFetch","method","params","body","headers","request","apiToken","url","queryParams","defaultHeaders","Authorization","userHeaders","mergedHeaders","transformedBody","contentType","getHeaderValue","formEncodedBody","response","status","statusText","ok","bodyToApiError","bodyToResponse","json","text","entries","value","encodeURIComponent","fields","candidateKey","V1_AUTH_ISSUE","V0_FETCH_BLOCK_ID_BY_TIME","V0_FETCH_TRANSACTION","V0_STATE_ABI","V0_STATE_ABI_BIN_TO_JSON","V0_STATE_KEY_ACCOUNTS","V0_STATE_PERMISSION_LINKS","V0_STATE_TABLE","V0_STATE_TABLE_ROW","V0_STATE_TABLES_SCOPES","V0_STATE_TABLES_ACCOUNTS","V0_STATE_TABLE_SCOPES","V0_SEARCH_TRANSACTIONS","createSocket","DefaultSocket","id","autoReconnect","reconnectDelayInMs","DEFAULT_RECONNECT_DELAY_IN_MS","keepAlive","keepAliveIntervalInMs","DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS","webSocketFactory","inferWebSocketFactory","webSocketProtocols","WebSocket","noop","isConnected","connectionPromise","keepAliveOption","registerKeepAliveHandler","socket","readyState","onReconnect","event","onError","commonOnSocketCloseFactory","reconnect","tryReconnect","tag","reconnectWorker","closeResolver","closePromise","cleanSocket","onClose","disconnectInitiator","onTerminationListener","listener","reconnectDelay","setTimeout","createAnOpenSocket","onSocketReconnectOpenFactory","onSocketReconnectErrorFactory","onSocketReconnectCloseFactory","onReconnectListener","onTermination","onSocketConnectOpenFactory","onSocketErrorFactory","onSocketCloseFactory","close","send","onSocketOpen","onSocketError","onSocketClose","onSocketFactoryError","buildUrl","onopen","onerror","onclose","onmessage","onSocketMessage","includes","keepAliveInterval","intervalHandler","setInterval","clearInterval","unregisterKeepAliveHandler","InboundMessageType","Deferred","activePromise","resolver","rejecter","reason","createStreamClient","wsUrl","DefaultStreamClient","socketOptions","autoRestartStreamsOnReconnect","rawMessage","debugTrace","ERROR","LISTENING","UNLISTENED","stream","streams","onMessage","streamId","restart","disconnect","setApiToken","connect","handleMessage","handleReconnection","DefaultStream","unregisterStream","start","registrationMessage","streamExists","activeJoiner","onMessageHandler","activeMarker","marker","checkMarker","restartMessage","start_block","atBlockNum","onPostRestart","promise","waitFor","DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS","DefaultGrahqlStreamClient","autoRestartStreamsOnError","restartOnErrorDelayInMs","autoDisconnectSocket","connectionEstablisher","payload","errors","terminal","onStreamCloseError","isActive","closeError","establish","all","finalizer","GraphqlConnectionEstablisher","variables","DefaultGraphqlStream","onUnregister","registrationDocument","registrationVariables","active","createStartMessage","cursor","resolvedVariables","query","unregisterError","activeDeferred","activeSocket","complete","createRefreshScheduler","DefaultRefreshScheduler","renewalTimeout","clearRefreshTimeout","job","onJobFailed","clearTimeout","MAX_UINT32_INTEGER","clientInstanceId","networkToEndpoint","network","DefaultClient","endpoints","httpClient","streamClient","graphqlStreamClient","requestIdGenerator","startsWith","apiTokenManager","authIssue","operationType","isValidDocumentType","onMessageProvided","withApiToken","registerStream","inferOperationType","apiRequest","websocketStream","messageCreator","withDefaultOptions","GET_ACTION_TRACES","listen","GET_TABLE_ROWS","GET_TRANSACTION_LIFECYCLE","GET_HEAD_INFO","initMessageFactory","authRequest","api_key","time","comparator","timeString","toISOString","q","startBlock","sort","block_count","blockCount","limit","with_reversible","withReversible","account","block_num","blockNum","hexRows","hex_rows","publicKey","public_key","scope","key_type","keyType","with_block_num","withBlockNum","with_abi","withAbi","primaryKey","primary_key","accounts","Content-Type","scopes","getTokenInfo","worker","predefinedOperationType","matches","randomReqId","random","messages","checkApiKey","endpoint","secureEndpoint","secure","restUrl","websocketUrl","graphqlQueryUrl","graphqlStreamUrl","httpClientOptions","streamClientOptions","createGraphqlStreamClient","graphqlStreamClientOptions","inferApiTokenStore","typeToDispatcher","dispatcher","transaction","execution_trace","state","actions","action_traces","actionTrace","walkFlattenedActionTraces","rootActionTrace","childActionTraces","inline_traces","childActionTrace","streamOptions","searchRow","lifecycle","matchingActionIndexes","action_idx","walkMatchingActionTraces"],"mappings":"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"}