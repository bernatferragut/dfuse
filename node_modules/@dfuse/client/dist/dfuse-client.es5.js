import debugFactory from 'debug';
import crypto from 'crypto';
import fs from 'fs';
import os from 'os';
import path from 'path';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const DEFAULT_DELAY_BUFFER_PERCENT = 0.95;
/**
 * Create the standard [[ApiTokenManager]] interface that will manage all the lifecycle
 * of a token.
 *
 * @param fetchTokenInfo The async function that should be used to retrieve a fresh token.
 * @param onTokenRefresh The function to call when a token has been refreshed.
 * @param delayBuffer The percentage of time to use to schedule the next token refresh
 *                    (i.e. with a value of `0.9` and a token valid for 1000ms from now,
 *                    the next refresh would be scheduled to happen at `now + (0.9 * 1000)`)
 * @param apiTokenStore The API token store interface to retrieve token from and to save it back to.
 * @param refreshScheduler The scheduler interface that should be used to schedule upcoming refresh token
 *                         and check if a scheduled one already exist.
 *
 * @kind Factories
 */
function createApiTokenManager(fetchTokenInfo, onTokenRefresh, delayBuffer, apiTokenStore, refreshScheduler) {
    return new DefaultApiTokenManager(fetchTokenInfo, onTokenRefresh, delayBuffer, apiTokenStore, refreshScheduler);
}
/**
 * Create the Noop [[ApiTokenManager]] interface that will manage all the lifecycle
 * of a token.
 *
 * @param token The hardwired token value (default value -> `a.b.c`)
 *
 * @kind Factories
 */
function createNoopApiTokenManager(token) {
    return new NoopApiTokenManager(token);
}
/**
 * Check wheter the received [[ApiTokenInfo]] parameter is expired or near its
 * expiration.
 */
function isApiTokenExpired(tokenInfo) {
    const now = Date.now() / 1000;
    return tokenInfo.expires_at <= now;
}
class DefaultApiTokenManager {
    constructor(fetchTokenInfo, onTokenRefresh, delayBuffer, apiTokenStore, refreshScheduler) {
        this.fetchTokenInfo = fetchTokenInfo;
        this.onTokenRefresh = onTokenRefresh;
        this.delayBuffer = delayBuffer;
        this.apiTokenStore = apiTokenStore;
        this.refreshScheduler = refreshScheduler;
        this.debug = debugFactory("dfuse:token-manager");
    }
    release() {
        this.debug("Releasing default API token manager");
        this.refreshScheduler.release();
        this.apiTokenStore.release();
    }
    getTokenInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenInfo = yield this.apiTokenStore.get();
            if (tokenInfo && !isApiTokenExpired(tokenInfo)) {
                this.maybeScheduleNextRefresh(tokenInfo, { forceRefresh: false });
                this.debug("Returning token found in API token store since it was still valid");
                return Promise.resolve(tokenInfo);
            }
            this.debug("Returning a fresh API token as it was not present in store or expired");
            return yield this.refreshToken();
        });
    }
    refreshToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenInfo = yield this.internalFetchToken();
            this.debug("Retrieved an API token that is going to expires at %s (%s)", new Date(tokenInfo.expires_at * 1000), tokenInfo.token);
            this.maybeScheduleNextRefresh(tokenInfo, { forceRefresh: true });
            try {
                this.debug("Storing API token into token storage");
                yield this.apiTokenStore.set(tokenInfo);
            }
            catch (error) {
                this.debug("Storing token into storage failed %s (%o)", error, error);
            }
            this.debug("Notifying upstream listener that API token has been refreshed.");
            this.onTokenRefresh(tokenInfo.token);
            return tokenInfo;
        });
    }
    maybeScheduleNextRefresh(tokenInfo, options) {
        if (!options.forceRefresh && this.refreshScheduler.hasScheduledJob()) {
            return;
        }
        const delayInSeconds = this.getRefreshDelayInSeconds(tokenInfo);
        const refreshAt = new Date(Date.now() + delayInSeconds * 1000);
        this.debug("Scheduling next token refresh to occur at %s (in %s seconds)", refreshAt, delayInSeconds);
        this.refreshScheduler.schedule(delayInSeconds, () => this.refreshToken());
    }
    getRefreshDelayInSeconds(tokenInfo) {
        const nowInSeconds = Math.floor(Date.now() / 1000);
        return (tokenInfo.expires_at - nowInSeconds) * this.delayBuffer;
    }
    internalFetchToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fetchTokenPromise !== undefined) {
                return this.fetchTokenPromise;
            }
            this.fetchTokenPromise = new Promise((resolve, reject) => {
                this.fetchTokenInfo()
                    .then((apiTokenInfo) => {
                    this.fetchTokenPromise = undefined;
                    resolve(apiTokenInfo);
                })
                    .catch((error) => {
                    this.fetchTokenPromise = undefined;
                    reject(error);
                });
            });
            return this.fetchTokenPromise;
        });
    }
}
class NoopApiTokenManager {
    constructor(token) {
        this.token = token || "a.b.c";
        this.expiresAt = 0;
        this.debug = debugFactory("dfuse:token-manager-noop");
    }
    release() {
        this.debug("Releasing default API token manager");
    }
    getTokenInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return { token: this.token, expires_at: this.expiresAt };
        });
    }
}

class DfuseError extends Error {
    constructor(message, cause) {
        super(message);
        this.description = message;
        this.cause = cause;
    }
}
class DfuseApiError extends DfuseError {
    constructor(data, cause) {
        super(data.message, cause);
        this.code = data.code;
        this.trace_id = data.trace_id;
        this.message = data.message;
        this.details = data.details;
    }
}
class DfuseClientError extends DfuseError {
    constructor(message, cause) {
        super(message, cause);
    }
}
class DfuseSocketError extends DfuseError {
    constructor(message, cause) {
        super(message, cause);
    }
}

/**
 * Represents an in-memory token storage concrete implementation of
 * a . This simply keep the token in variable and serves
 * it from there.
 *
 * It is **never** persisted and will be reset upon restart of the Browser tab
 * or process, leading to a new token being issued.
 *
 * You should try hard to use a persistent solution so that you re-use the
 * same token as long as it's valid.
 */
class InMemoryApiTokenStore {
    release() {
        return;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiTokenInfo;
        });
    }
    set(apiTokenInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.apiTokenInfo = apiTokenInfo;
        });
    }
}
/**
 * Represents an [[ApiTokenStore]] that saves the token as a JSON string
 * in the `localStorage` of the Browser.
 *
 * Trying to use this class when `window.localStorage` is not a function
 * (like in a Node.js environment) will throw an error at construction
 * time. Use another implementation. If this error is thrown nonetheless
 * in your Browser, local storage is probably not supported there.
 *
 * It is persisted in the local storage of the Browser it will be picked up
 * upon restart of the Browser tab.
 */
class LocalStorageApiTokenStore {
    constructor(key) {
        this.key = key;
        if (typeof localStorage !== "object") {
            const messages = [
                "This environment does not contain a valid `localStorage` object in the global scope to use.",
                "",
                "You are most likely in a Node.js environment where a global `localStorage` is not available by default.",
                "This API token store concrete impelementation is not usable in your environment. You should be",
                "providing a different implementation of ApiTokenInfo.",
                "",
                "If this error occurred when you did not provide yourself the instance, it means our auto-detection",
                "mechanism incorrectly thought it could use `LocalStorageApiTokenStore` instance while it should",
                "have not. Please report a bug about this issue so we can fix it.",
                "",
                "If you provided the instance yourself, you should read our documentation to better",
                "understand what you should provide here.",
                "",
                "See https://github.com/dfuse-io/client-js"
            ];
            throw new DfuseClientError(messages.join("\n"));
        }
    }
    release() {
        return;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiTokenInfo !== undefined) {
                return this.apiTokenInfo;
            }
            const raw = localStorage.getItem(this.key);
            if (raw == null) {
                return undefined;
            }
            this.apiTokenInfo = JSON.parse(raw);
            return this.apiTokenInfo;
        });
    }
    set(apiTokenInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.apiTokenInfo = apiTokenInfo;
            localStorage.setItem(this.key, JSON.stringify(apiTokenInfo));
        });
    }
}
/**
 * Represents an [[ApiTokenStore]] implementation that will save
 * as a JSON string in plain text in the given file.
 *
 * The directory structure is created when it does not exists.
 *
 * **Note** This cannot be used in a browser environment
 */
class FileApiTokenStore {
    constructor(filePath) {
        this.filePath = filePath;
    }
    release() {
        return;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.apiTokenInfo !== undefined) {
                return this.apiTokenInfo;
            }
            const data = yield readData(this.filePath);
            if (data === undefined) {
                return undefined;
            }
            this.apiTokenInfo = JSON.parse(data);
            return this.apiTokenInfo;
        });
    }
    set(apiTokenInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.apiTokenInfo = apiTokenInfo;
            yield writeData(this.filePath, JSON.stringify(apiTokenInfo));
        });
    }
}
/**
 * Represents an [[ApiTokenStore]] implementation that will save
 * as a JSON string in a file located at
 * `~/.dfuse/<sha256-api-key>/token.json`.
 *
 * The directory structure is created when it does not exists.
 *
 * **Note** This cannot be used in a browser environment.
 */
class OnDiskApiTokenStore extends FileApiTokenStore {
    constructor(apiKey) {
        const homeDirectory = os.homedir();
        const sha256sum = crypto.createHash("sha256");
        super(`${homeDirectory}/.dfuse/${sha256sum.update(apiKey).digest("hex")}/token.json`);
    }
}
function readData(filePath) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (!fs.existsSync(filePath)) {
                resolve(undefined);
                return;
            }
            fs.readFile(filePath, (error, data) => {
                error ? reject(error) : resolve(data);
            });
        });
    });
}
function writeData(filePath, data) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            try {
                mkdirpSync(path.dirname(filePath));
            }
            catch (error) {
                reject(error);
                return;
            }
            fs.writeFile(filePath, data, (error) => {
                error ? reject(error) : resolve();
            });
        });
    });
}
function mkdirpSync(directory) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!path.isAbsolute(directory)) {
            return;
        }
        const parent = path.join(directory, "..");
        if (parent !== path.join("/") && !fs.existsSync(parent)) {
            mkdirpSync(parent);
        }
        if (!fs.existsSync(directory)) {
            fs.mkdirSync(directory);
        }
    });
}

// **Important** The key must be the same as the API type but in upper snake case for "in" operation to work
var OutboundMessageType;
(function (OutboundMessageType) {
    OutboundMessageType["GET_ACTION_TRACES"] = "get_action_traces";
    OutboundMessageType["GET_TABLE_ROWS"] = "get_table_rows";
    OutboundMessageType["GET_TRANSACTION_LIFECYCLE"] = "get_transaction_lifecycle";
    OutboundMessageType["GET_HEAD_INFO"] = "get_head_info";
    OutboundMessageType["UNLISTEN"] = "unlisten";
})(OutboundMessageType || (OutboundMessageType = {}));
function getActionTracesMessage(data, streamOptions = {}) {
    return createOutboundMessage(OutboundMessageType.GET_ACTION_TRACES, data, Object.assign({ listen: true }, streamOptions));
}
/**
 * @deprecated The message factories are deprecated, there is no need to create your
 *             own message anynore. This will be removed in a future release. The standard
 *             client does not use this anymore.
 */
function getTableRowsMessage(data, streamOptions = {}) {
    return createOutboundMessage(OutboundMessageType.GET_TABLE_ROWS, data, Object.assign({ listen: true }, streamOptions));
}
/**
 * @deprecated The message factories are deprecated, there is no need to create your
 *             own message anynore. This will be removed in a future release. The standard
 *             client does not use this anymore.
 */
function getTransactionLifecycleMessage(data, streamOptions = {}) {
    return createOutboundMessage(OutboundMessageType.GET_TRANSACTION_LIFECYCLE, data, Object.assign({ listen: true, fetch: true }, streamOptions));
}
/**
 * @deprecated The message factories are deprecated, there is no need to create your
 *             own message anynore. This will be removed in a future release. The standard
 *             client does not use this anymore.
 */
function getHeadInfoMessage(streamOptions = {}) {
    return createOutboundMessage(OutboundMessageType.GET_HEAD_INFO, {}, Object.assign({ listen: true }, streamOptions));
}
/**
 * @deprecated The message factories are deprecated, there is no need to create your
 *             own message anynore. This will be removed in a future release. The standard
 *             client does not use this anymore.
 */
function unlistenMessage(data) {
    return {
        req_id: data.req_id,
        type: OutboundMessageType.UNLISTEN,
        data
    };
}
/**
 * Exported for consumption from internal packages. This does **not**
 * have any **Backward compatibility** policy nor documentation attached
 * to it.
 *
 * It will be moved and made private again when message factories
 * above have been removed.
 */
function createOutboundMessage(type, data, options) {
    const req_id = options.req_id;
    if (req_id === undefined) {
        throw new DfuseClientError("All outbound message should have a 'req_id' value");
    }
    return Object.assign({ type,
        req_id,
        data }, options);
}

/**
 * Create the default [[HttpClient]] concrete implementation.
 *
 * @param authUrl The full dfuse Authentication url to use to perform the `authRequest` calls.
 * @param apiUrl The full dfuse REST API url to use to perform the `apiRequest` calls.
 * @param options The set of options used to construct the default [[HttpClient]] instance. See
 * [[HttpClientOptions]] for documentation of the options and default values for each of them.
 */
function createHttpClient(authUrl, apiUrl, options = {}) {
    return new DefaultHttpClient(authUrl, apiUrl, inferFetch(options.fetch));
}
function inferFetch(fetch) {
    const debug = debugFactory("dfuse:http");
    if (fetch !== undefined) {
        debug("Using user provided `fetch` option.");
        return fetch;
    }
    // In both of the condition below to determine a global `fetch` to use,
    // we bind the `fetch` method to the global scope (either `window` or `global`
    // depending on the target environment).
    //
    // It happens in a bundler environment like WebPack that the `fetch` method
    // loses it's contextual `this` variable. The `this` is used internal by the
    // implementation for certain features of the specification.
    //
    // By doing a `.bind(<global scope>)`, we ensure the `fetch` remains bound
    // to the correct `this` variable.
    // If we are in a Browser environment and `fetch` is available, use it
    if (typeof window !== "undefined" && window.fetch != null) {
        debug("Using `fetch` global value found on 'window' variable (Browser environment).");
        return window.fetch.bind(window);
    }
    // If we are in a Node.js like environment and `fetch` is available, use it
    if (typeof global !== "undefined" && global.fetch != null) {
        debug("Using `fetch` global value found on 'global' variable (Node.js environment).");
        return global.fetch.bind(global);
    }
    // Otherwise, throw an exception
    const messages = [
        "You did not provide a `fetch` option and we were not able to infer one from the global scope.",
        "",
        "You are most likely in a Node.js environment where a global `fetch` is not available by defaut.",
        "To resolve the issue, either pass a compatible `fetch` option or globally defined a `global.fetch`",
        "variable pointing to a compatible `fetch` method.",
        "",
        "We invite you to read our documentation to learn more about this problem.",
        "",
        "See https://github.com/dfuse-io/client-js#nodejs"
    ];
    throw new DfuseClientError(messages.join("\n"));
}
/**
 * The `DefaultHttpClient` is responsible of performing the actual HTTP
 * calls transforming the parameters into an actual HTTP request and
 * turning back the HTTP response into a return value.
 *
 * All methods are asynchronous and returns a response object when successufl
 * and throws a `DfuseError` when an error is encountered.
 */
class DefaultHttpClient {
    constructor(authUrl, apiUrl, fetch) {
        this.debug = debugFactory("dfuse:http");
        this.authUrl = authUrl;
        this.apiUrl = apiUrl;
        this.fetch = fetch;
    }
    release() {
        return;
    }
    authRequest(path, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(undefined, this.authUrl + path, method, params, body, headers);
        });
    }
    apiRequest(apiToken, path, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(apiToken, this.apiUrl + path, method, params, body, headers);
        });
    }
    request(apiToken, url, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("Preparing request [%s %s](%o)", method, url, params);
            if (params && Object.keys(params).length > 0) {
                url += "?" + this.queryParams(params);
            }
            const defaultHeaders = {};
            if (apiToken !== undefined) {
                defaultHeaders.Authorization = `Bearer ${apiToken}`;
            }
            const userHeaders = headers || {};
            const mergedHeaders = Object.assign(Object.assign({}, defaultHeaders), userHeaders);
            let transformedBody;
            if (body !== undefined) {
                const contentType = this.getHeaderValue(mergedHeaders, "content-type");
                if (contentType === undefined || contentType === "application/json") {
                    transformedBody = JSON.stringify(body);
                }
                else if (contentType === "application/x-www-form-urlencoded") {
                    transformedBody = this.formEncodedBody(body);
                }
                else {
                    transformedBody = body;
                }
            }
            try {
                this.debug("Executing request [%s %s](headers: %o, bodyLength: %s)", method, url, mergedHeaders, (transformedBody || "").length);
                const response = yield this.fetch(url, {
                    headers: mergedHeaders,
                    method,
                    body: transformedBody
                });
                this.debug("Received response [%s %s %s](headers: %o)", response.status, response.statusText, response.url, response.headers);
                if (!response.ok) {
                    this.debug("Request returned with an error HTTP code %s", response.status);
                    throw yield this.bodyToApiError(response);
                }
                this.debug("Turning response body into response result");
                return yield this.bodyToResponse(response);
            }
            catch (error) {
                if (error instanceof DfuseError) {
                    throw error;
                }
                throw new DfuseClientError("Unable to perform HTTP request correctly", error);
            }
        });
    }
    bodyToResponse(response) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield response.json();
            }
            catch (error) {
                throw new DfuseClientError("The returned body shall have been a valid JSON object", error);
            }
        });
    }
    bodyToApiError(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = yield response.text();
            try {
                return new DfuseApiError(JSON.parse(body));
            }
            catch (error) {
                return new DfuseClientError(`The returned body shall have been a valid JSON object, got '${body}'`, error);
            }
        });
    }
    queryParams(params) {
        const entries = [];
        for (const key of Object.keys(params)) {
            const value = params[key];
            if (value !== undefined) {
                entries.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }
        }
        return entries.join("&");
    }
    formEncodedBody(fields) {
        const entries = [];
        for (const key of Object.keys(fields)) {
            const value = fields[key];
            if (value !== undefined) {
                entries.push(key + "=" + value);
            }
        }
        return entries.join("&");
    }
    // FIXME: In real world scenario, an HTTP header can appear more than onced, but we do not
    //        deal with this case here yet.
    getHeaderValue(headers, key) {
        for (const candidateKey in headers) {
            if (candidateKey.toLowerCase() === key.toLowerCase()) {
                return headers[candidateKey];
            }
        }
        return undefined;
    }
    hasHeaderKey(headers, key) {
        return this.getHeaderValue(headers, key) !== undefined;
    }
}

const V1_AUTH_ISSUE = "/v1/auth/issue";
const V0_FETCH_BLOCK_ID_BY_TIME = "/v0/block_id/by_time";
const V0_FETCH_TRANSACTION = "/v0/transactions/:id";
const V0_STATE_ABI = "/v0/state/abi";
const V0_STATE_ABI_BIN_TO_JSON = "/v0/state/abi/bin_to_json";
const V0_STATE_KEY_ACCOUNTS = "/v0/state/key_accounts";
const V0_STATE_PERMISSION_LINKS = "/v0/state/permission_links";
const V0_STATE_TABLE = "/v0/state/table";
const V0_STATE_TABLE_ROW = "/v0/state/table/row";
const V0_STATE_TABLES_SCOPES = "/v0/state/tables/scopes";
const V0_STATE_TABLES_ACCOUNTS = "/v0/state/tables/accounts";
const V0_STATE_TABLE_SCOPES = "/v0/state/table_scopes";
const V0_SEARCH_TRANSACTIONS = "/v0/search/transactions";

/**
 * Create an actual [[Socket]] instance that will be used as the interface to wrap all
 * communicaton of the WebSocket protocol.
 *
 * @param url The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter.
 * @param options The options used to configure the [[Socket]] instance, see [[SocketOptions]] for default options.
 */
function createSocket(url, options = {}) {
    return new DefaultSocket(url, Object.assign({ id: "", autoReconnect: true, reconnectDelayInMs: DEFAULT_RECONNECT_DELAY_IN_MS, keepAlive: true, keepAliveIntervalInMs: DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS, webSocketFactory: inferWebSocketFactory(options.id, options.webSocketProtocols, options.webSocketFactory) }, options));
}
function inferWebSocketFactory(id, webSocketProtocols, webSocketFactory) {
    const debug = debugFactory("dfuse:socket" + (id ? `:${id}` : ""));
    if (webSocketFactory !== undefined) {
        debug("Using user provided `webSocketFactory` option.");
        return webSocketFactory;
    }
    // If we are in a Browser environment and `WebSocket` is available, use it
    if (typeof window !== "undefined" && window.WebSocket != null) {
        debug("Using `WebSocket` global value found on 'window' variable (Browser environment).");
        return (url) => __awaiter(this, void 0, void 0, function* () { return new window.WebSocket(url, webSocketProtocols); });
    }
    // If we are in a Node.js like environment and `WebSocket` is available, use it
    if (typeof global !== "undefined" && global.WebSocket != null) {
        debug("Using `WebSocket` global value found on 'global' variable (Node.js environment).");
        return (url) => __awaiter(this, void 0, void 0, function* () { return new global.WebSocket(url, webSocketProtocols, {}); });
    }
    // Otherwise, throw an exception
    const messages = [
        "You did not provide a `webSocket` option and we were not able find a `WebSocket` object in",
        "the global scope to create use.",
        "",
        "You are most likely in a Node.js environment where a global `WebSocket` is not available by default.",
        "To resolve the issue, either pass a compatible `webSocket` option or globally defined a `global.WebSocket`",
        "variable pointing to a compatible `WebSocket` client.",
        "",
        "We invite you to read our documentation to learn more about this problem.",
        "",
        "See https://github.com/dfuse-io/client-js#nodejs"
    ];
    throw new DfuseClientError(messages.join("\n"));
}
const noop = () => {
    return;
};
const DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS = 30000; // 30s
const DEFAULT_RECONNECT_DELAY_IN_MS = 2500; // 2.5s
class DefaultSocket {
    constructor(url, options) {
        this.isConnected = false;
        this.onSocketConnectOpenFactory = (resolve) => () => {
            this.debug("Received `onopen` (via connect) notification from socket.");
            this.isConnected = true;
            this.connectionPromise = undefined;
            if (this.keepAliveOption() === true) {
                this.registerKeepAliveHandler();
            }
            this.debug("Signaling completion of `connect` method in the outer scope.");
            resolve();
        };
        this.onSocketReconnectOpenFactory = (resolve) => () => {
            this.debug("Received `onopen` (via reconnect) notification from socket with ready state %d.", this.socket.readyState);
            this.isConnected = true;
            this.connectionPromise = undefined;
            if (this.keepAliveOption() === true) {
                this.registerKeepAliveHandler();
            }
            this.debug("Signaling completion of `reconnect` method in the outer scope.");
            resolve(true);
            this.debug("Sending a `onReconnect` notification to client consumer.");
            this.onReconnect();
        };
        this.onSocketErrorFactory = (reject) => (event) => {
            this.debug("Received `onerror` notification from socket (%s).", event.error);
            // The official WebSocket flow is to always send an `onclose` event after an `onerror`
            // ones, as such, we must not clean the socket at this point. We must always
            // wait and ensures the `onclose` event will be called and that clean up will
            // happen in the `onclose` handler.
            this.debug("Signaling rejection of connection in the outer scope.");
            reject(event);
            this.debug("Sending an `onError` notification to client consumer.");
            this.onError(event);
        };
        this.onSocketReconnectErrorFactory = () => (event) => {
            this.debug("Received `onerror` (via reconnect) notification from socket.");
            this.debug("Sending an `onError` notification to client consumer.");
            this.onError(event);
        };
        this.onSocketCloseFactory = () => {
            return this.commonOnSocketCloseFactory("connect", () => {
                this.reconnect().catch((error) => {
                    this.debug("The re-connection never succeed, will not retry anymore.", error);
                });
            });
        };
        this.onSocketReconnectCloseFactory = (resolve, reject) => {
            return this.commonOnSocketCloseFactory("reconnect", () => {
                this.tryReconnect(resolve, reject);
            });
        };
        this.commonOnSocketCloseFactory = (tag, reconnectWorker) => (event) => {
            this.debug("Received `onclose` (via %s) notification from socket.", tag);
            this.isConnected = false;
            this.connectionPromise = undefined;
            if (this.closeResolver) {
                this.debug("Resolving disconnect close promise (via %s).", tag);
                this.closeResolver();
                this.closeResolver = undefined;
                this.closePromise = undefined;
            }
            this.cleanSocket();
            this.debug("Sending a `onClose` (%d) notification to client consumer (via %s).", event.code, tag);
            this.onClose(event);
            if (event.code !== 1000 &&
                event.code !== 1009 &&
                this.disconnectInitiator !== "client" &&
                this.options.autoReconnect) {
                this.debug("Socket has close abnormally (via %s), trying to re-connect to socket (infinite retry).", tag);
                reconnectWorker();
            }
            else {
                this.debug("Terminating socket lifecycle (via %s), no reconnection will be attempted.", tag);
                if (this.onTerminationListener) {
                    this.onTerminationListener();
                }
                this.disconnectInitiator = undefined;
            }
        };
        this.onSocketMessage = (event) => {
            let message;
            try {
                message = JSON.parse(event.data);
            }
            catch (error) {
                this.debug("Received a non-JSON message, are you sure you are talking to dfuse API?");
                return;
            }
            if (this.listener) {
                this.listener(message);
            }
        };
        this.tryReconnect = (resolve, reject) => {
            let reconnectDelay = this.options.reconnectDelayInMs;
            if (reconnectDelay === undefined) {
                reconnectDelay = DEFAULT_RECONNECT_DELAY_IN_MS;
            }
            this.debug(`Waiting ${reconnectDelay}ms before trying to perform the re-connection.`);
            setTimeout(() => {
                this.createAnOpenSocket(this.onSocketReconnectOpenFactory(resolve), this.onSocketReconnectErrorFactory(), this.onSocketReconnectCloseFactory(resolve, reject), reject);
            }, reconnectDelay);
        };
        this.url = url;
        this.options = options;
        this.debug = debugFactory("dfuse:socket" + (options.id !== "" ? `:${options.id}` : ""));
    }
    setApiToken(apiToken) {
        this.debug("Socket API token updated to %s.", apiToken);
        this.apiToken = apiToken;
    }
    connect(listener, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to connect to remote endpoint.");
            if (this.connectionPromise !== undefined) {
                return this.connectionPromise;
            }
            if (this.isConnected) {
                return;
            }
            this.listener = listener;
            this.onReconnectListener = options.onReconnect;
            this.onTerminationListener = options.onTermination;
            this.connectionPromise = new Promise((resolve, reject) => {
                this.debug("Connection promise started, creating and opening socket.");
                this.createAnOpenSocket(this.onSocketConnectOpenFactory(resolve), this.onSocketErrorFactory(reject), this.onSocketCloseFactory(), reject);
            });
            this.debug("Connection to remote endpoint in-progress, returning promise to caller.");
            return this.connectionPromise;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to disconnect from remote endpoint.");
            if (this.closePromise) {
                this.debug("A disconnect is already in progress, joining it for termination.");
                return this.closePromise;
            }
            if (this.socket === undefined) {
                return;
            }
            this.onReconnectListener = undefined;
            this.listener = undefined;
            this.debug("Closing socket.");
            this.socket.close();
            // We must not clean up the socket at this point yet. Cleaning up the socket means
            // removing the actual event listeners. If you clean up just yet, the `onclose` event
            // will not be handled and the consumer of the library does not receive its own
            // `onClose` event. Instead, let's do the clean up once we receive the socket
            // `onclose` event.
            this.debug("Lazily disconnected, remaining clean up shall be performed when receiving `onclose` event.");
            this.isConnected = false;
            this.disconnectInitiator = "client";
            this.closePromise = new Promise((resolve) => {
                // Shall be resolved by the `onClose` event handler on this class
                this.closeResolver = resolve;
            });
            return this.closePromise;
        });
    }
    send(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected) {
                this.debug("Not connected, re-connecting prior sending message.");
                yield this.reconnect();
            }
            if (!this.isConnected) {
                this.debug("Socket not connected, unable to send message correctly.");
                throw new DfuseSocketError("Socket not connected, unable to send message correctly.");
            }
            this.debug("Sending message %o through socket.", message);
            this.socket.send(JSON.stringify(message));
        });
    }
    createAnOpenSocket(onSocketOpen, onSocketError, onSocketClose, onSocketFactoryError) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.buildUrl();
            this.debug("Starting connection handshake with remote url %s.", url);
            try {
                const socket = yield this.options.webSocketFactory(url);
                socket.onopen = onSocketOpen;
                socket.onerror = onSocketError;
                socket.onclose = onSocketClose;
                socket.onmessage = this.onSocketMessage;
                this.socket = socket;
            }
            catch (error) {
                onSocketFactoryError(error);
            }
        });
    }
    buildUrl() {
        if (this.apiToken === undefined) {
            // FIXME: Shall we throw an exception instead?
            return this.url;
        }
        // FIXME: Decompose url, add query param api token if available, then re-compose url!
        if (this.url.includes("?")) {
            return `${this.url}&token=${this.apiToken}`;
        }
        return `${this.url}?token=${this.apiToken}`;
    }
    registerKeepAliveHandler() {
        const keepAliveInterval = this.options.keepAliveIntervalInMs || DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS;
        this.debug("Unregistering keep alive interval");
        this.intervalHandler = setInterval(() => {
            if (!this.isConnected || this.socket === undefined) {
                return;
            }
            this.debug("Sending keep alive pong through socket.");
            this.socket.send(JSON.stringify({ type: "pong" }));
        }, keepAliveInterval);
    }
    unregisterKeepAliveHandler() {
        if (this.intervalHandler === undefined) {
            return;
        }
        this.debug("Unregistering keep alive interval");
        clearInterval(this.intervalHandler);
        this.intervalHandler = undefined;
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("Reconnect has been invoked, perfoming initial re-connection logic.");
            if (this.connectionPromise) {
                try {
                    this.debug("Awaiting actual connection to complete.");
                    yield this.connectionPromise;
                    return true;
                }
                catch (error) {
                    this.debug("Original connection did not succeed, continuing re-connection process.");
                }
            }
            if (!this.options.autoReconnect) {
                this.debug("Not re-connecting because client consumer auto reconnect option is falsy.");
                return false;
            }
            return new Promise(this.tryReconnect);
        });
    }
    cleanSocket() {
        if (this.intervalHandler !== undefined) {
            this.unregisterKeepAliveHandler();
        }
        if (this.socket === undefined) {
            return;
        }
        this.socket.onopen = noop;
        this.socket.onclose = noop;
        this.socket.onerror = noop;
        this.socket.onmessage = noop;
        this.socket = undefined;
    }
    /**
     * We notify both the `onReconnect` option passed when constructing
     * the socket and the one (if present) that was passed when connecting
     * the socket.
     *
     * Those are two different listeners and must be both sent when possible.
     */
    onReconnect() {
        // Let's call the `connect` `onReconnectListener` first then followed
        // by the one the consumer of the socket passed
        if (this.onReconnectListener)
            this.onReconnectListener();
        if (this.options.onReconnect)
            this.options.onReconnect();
    }
    onClose(message) {
        if (this.options.onClose)
            this.options.onClose(message);
    }
    onError(message) {
        if (this.options.onError)
            this.options.onError(message);
    }
    keepAliveOption() {
        return this.options.keepAlive === undefined ? true : this.options.keepAlive;
    }
}

// **Important** The key must be the same as the API type but in upper snake case for "in" operation to work
var InboundMessageType;
(function (InboundMessageType) {
    InboundMessageType["ACTION_TRACE"] = "action_trace";
    InboundMessageType["ERROR"] = "error";
    InboundMessageType["LISTENING"] = "listening";
    InboundMessageType["HEAD_INFO"] = "head_info";
    InboundMessageType["PING"] = "ping";
    InboundMessageType["PROGRESS"] = "progress";
    InboundMessageType["UNLISTENED"] = "unlistened";
    InboundMessageType["TABLE_DELTA"] = "table_delta";
    InboundMessageType["TABLE_SNAPSHOT"] = "table_snapshot";
    InboundMessageType["TRANSACTION_LIFECYCLE"] = "transaction_lifecycle";
})(InboundMessageType || (InboundMessageType = {}));
// export type InboundMessageType = "action_trace"
//                                | "error"
//                                | "listening"
//                                | "head_info"
//                                | "ping"
//                                | "progress"
//                                | "unlistened"
//                                | "table_delta"
//                                | "table_snapshot"
//                                | "transaction_lifecycle"

class Deferred {
    constructor() {
        this.activePromise = new Promise((resolve, reject) => {
            this.resolver = resolve;
            this.rejecter = reject;
        });
    }
    promise() {
        return this.activePromise;
    }
    resolve(value) {
        this.resolver(value);
    }
    reject(reason) {
        this.rejecter(reason);
    }
}

/**
 * Create the default [[StreamClient]] concrete implementation.
 *
 * @param wsUrl The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter. Passed as
 * is to created [[Socket]] interface through the [[createSocket]] factory method. This parameter has no effect
 * if [[StreamClientOptions.socket]] options is used.
 * @param options The set of options used to construct the default [[StreamClient]] instance. See
 * [[StreamClientOptions]] for documentation of the options and default values for each of them.
 */
function createStreamClient(wsUrl, options = {}) {
    return new DefaultStreamClient(options.socket || createSocket(wsUrl, Object.assign({ id: "stream" }, options.socketOptions)), options.autoRestartStreamsOnReconnect === undefined
        ? true
        : options.autoRestartStreamsOnReconnect);
}
class DefaultStreamClient {
    constructor(socket, autoRestartStreamsOnReconnect) {
        this.debug = debugFactory("dfuse:stream");
        this.debugTrace = debugFactory("dfuse-trace:stream");
        this.streams = {};
        this.handleMessage = (rawMessage) => {
            const message = rawMessage;
            if (message.type === "ping") {
                this.debug("Discarding 'ping' message from reaching the underlying stream(s).");
                return;
            }
            let debug = this.debugTrace;
            if (message.type === InboundMessageType.ERROR ||
                message.type === InboundMessageType.LISTENING ||
                message.type === InboundMessageType.UNLISTENED) {
                debug = this.debug;
            }
            debug("Routing socket message of type '%s' with req_id '%s' to appropriate stream", message.type, message.req_id);
            const stream = this.streams[message.req_id || ""];
            if (stream === undefined) {
                this.debug("No stream currently registered able to handle message with req_id '%s'", message.req_id);
                return;
            }
            stream.onMessage(message, stream);
        };
        this.handleReconnection = () => {
            if (this.autoRestartStreamsOnReconnect === false) {
                return;
            }
            Object.keys(this.streams).forEach((streamId) => {
                this.streams[streamId].restart();
            });
        };
        this.socket = socket;
        this.autoRestartStreamsOnReconnect = autoRestartStreamsOnReconnect;
    }
    release() {
        this.debug("Releasing default stream client");
        this.socket.disconnect().catch((error) => {
            this.debug("An error occurred while disconnecting from socket while releasing instance", error);
        });
    }
    setApiToken(apiToken) {
        this.socket.setApiToken(apiToken);
    }
    registerStream(message, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.socket.isConnected) {
                this.debug("Socket is not connected, connecting socket first.");
                yield this.socket.connect(this.handleMessage, { onReconnect: this.handleReconnection });
            }
            const id = message.req_id;
            if (this.streams[id] !== undefined) {
                throw new DfuseClientError(`A stream with id '${id}' is already registered, cannot register another one with the same id`);
            }
            this.debug("Registering stream [%s] with message %o.", id, message);
            const streamExists = (streamId) => this.streams[streamId] !== undefined;
            const unregisterStream = (streamId) => this.unregisterStream(streamId);
            const stream = new DefaultStream(id, message, onMessage, streamExists, unregisterStream, this.socket, this.debug.extend(id, ":"));
            // Let's first register stream to ensure that if messages arrives before we got back
            // execution flow after `send` call, the listener is already present to handle message
            this.streams[id] = stream;
            try {
                yield stream.start();
            }
            catch (error) {
                delete this.streams[id];
                throw new DfuseClientError(`Unable to correctly register stream '${id}'`, error);
            }
            this.debug("Stream [%s] registered with remote endpoint.", id);
            return stream;
        });
    }
    unregisterStream(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.streams[id] === undefined) {
                this.debug("Stream [%s] is already unregistered, nothing to do.", id);
                return;
            }
            const message = unlistenMessage({ req_id: id });
            this.debug("Unregistering stream [%s] with message %o.", id, message);
            delete this.streams[id];
            if (this.socket.isConnected) {
                yield this.socket.send(message);
            }
            if (Object.keys(this.streams).length <= 0) {
                this.debug("No more stream present, disconnecting socket.");
                if (this.socket.isConnected) {
                    yield this.socket.disconnect();
                }
            }
        });
    }
}
class DefaultStream {
    constructor(id, registrationMessage, onMessage, streamExists, unregisterStream, socket, debug) {
        this.resolve = () => {
            if (this.activeJoiner) {
                this.debug("Resolving joiner promise.");
                this.activeJoiner.resolve();
                this.activeJoiner = undefined;
            }
        };
        this.reject = (error) => {
            if (this.activeJoiner) {
                this.debug("Rejecting joiner promise with error %o.", error);
                this.activeJoiner.reject(error);
                this.activeJoiner = undefined;
            }
        };
        this.id = id;
        this.registrationMessage = registrationMessage;
        this.onMessageHandler = onMessage;
        this.streamExists = streamExists;
        this.unregisterStream = unregisterStream;
        this.socket = socket;
        this.debug = debug;
    }
    get onMessage() {
        return this.onMessageHandler;
    }
    currentActiveMarker() {
        return this.activeMarker;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.socket.send(this.registrationMessage);
        });
    }
    restart(marker) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkMarker(marker);
            if (!this.streamExists(this.id)) {
                throw new DfuseClientError(`Trying to restart a stream '${this.id}' that is not registered anymore or was never registered`);
            }
            let activeMarker = this.activeMarker;
            if (marker) {
                activeMarker = marker;
            }
            const restartMessage = Object.assign({}, this.registrationMessage);
            if (activeMarker) {
                restartMessage.start_block = activeMarker.atBlockNum;
            }
            yield this.socket.send(restartMessage);
            if (this.onPostRestart) {
                this.onPostRestart();
            }
        });
    }
    join() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeJoiner !== undefined) {
                return this.activeJoiner.promise();
            }
            this.activeJoiner = new Deferred();
            return this.activeJoiner.promise();
        });
    }
    mark(marker) {
        this.activeMarker = this.checkMarker(marker);
    }
    close(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (this.unregisterStream(this.id)
                .then(() => {
                if (options.error) {
                    this.reject(options.error);
                }
                else {
                    this.resolve();
                }
            })
                // FIXME: We should probably return a MultiError of some kind to report both error if `options.error` exists
                .catch(this.reject));
        });
    }
    checkMarker(marker) {
        if (!marker) {
            return undefined;
        }
        if (!marker.atBlockNum || marker.atBlockNum < 0) {
            throw new DfuseClientError("Only non-zero & positive `atBlockNum` markers are accepted for this operation");
        }
        return marker;
    }
}

function waitFor(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

const DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS = 2500; // 2.5s
/**
 * Create the default [[StreamClient]] concrete implementation.
 *
 * @param wsUrl The url used to reach the dfuse Stream API, should **not** contain the `token` query parameter. Passed as
 * is to created [[Socket]] interface through the [[createSocket]] factory method. This parameter has no effect
 * if [[StreamClientOptions.socket]] options is used.
 * @param options The set of options used to construct the default [[StreamClient]] instance. See
 * [[StreamClientOptions]] for documentation of the options and default values for each of them.
 */
function createGraphqlStreamClient(wsUrl, options = {}) {
    return new DefaultGrahqlStreamClient(options.socket ||
        createSocket(wsUrl, Object.assign({ id: "graphql", webSocketProtocols: "graphql-ws" }, options.socketOptions)), options.autoRestartStreamsOnReconnect === undefined
        ? true
        : options.autoRestartStreamsOnReconnect, options.autoRestartStreamsOnError === undefined ? true : options.autoRestartStreamsOnError, options.restartOnErrorDelayInMs === undefined
        ? DEFAULT_RESTART_ON_ERROR_DELAY_IN_MS
        : options.restartOnErrorDelayInMs, options.autoDisconnectSocket === undefined ? true : options.autoDisconnectSocket);
}
class DefaultGrahqlStreamClient {
    constructor(socket, autoRestartStreamsOnReconnect, autoRestartStreamsOnError, restartOnErrorDelayInMs, autoDisconnectSocket) {
        this.debug = debugFactory("dfuse:graphql-stream");
        this.debugTrace = debugFactory("dfuse-trace:graphql-stream");
        this.streams = {};
        this.handleMessage = (rawMessage) => __awaiter(this, void 0, void 0, function* () {
            const message = rawMessage;
            if (message.type === "ka") {
                this.debug("Discarding 'ka' (Keep Alive) message from reaching the underlying stream(s).");
                return;
            }
            if (message.type === "connection_ack" || message.type === "connection_error") {
                this.connectionEstablisher.onMessage(message);
                return;
            }
            let debug = this.debug;
            if (message.type === "data") {
                debug = this.debugTrace;
            }
            debug("Routing socket message of type '%s' with id '%s' to appropriate stream", message.type, message.id);
            const stream = this.streams[message.id || ""];
            if (stream === undefined) {
                this.debug("No stream currently registered able to handle message with 'id: %s'", message.id);
                return;
            }
            if (message.type === "data") {
                if (message.payload.errors) {
                    stream.onMessage({ type: "error", errors: message.payload.errors, terminal: false }, stream);
                }
                else {
                    stream.onMessage({ type: "data", data: message.payload.data }, stream);
                }
                // Let's not continue for a data message
                return;
            }
            const onStreamCloseError = (error) => {
                // FIXME: We shall pass this error somewhere, to some kind of notifier or event
                //        emitter but there is no such stuff right now.
                this.debug("Closing the stream [%s] (in response of GraphQL '%s' message) failed %O.", stream.id, message.type, error);
            };
            if (message.type === "error") {
                stream.onMessage({ type: "error", errors: [message.payload], terminal: true }, stream);
                if (this.autoRestartStreamsOnError) {
                    this.debug("Stream [%s] received error message and auto restart on error set, waiting [%d ms] before restarting", stream.id, this.restartOnErrorDelayInMs);
                    yield waitFor(this.restartOnErrorDelayInMs);
                    yield stream.restart().catch((error) => {
                        // Can only happen if the socket does not auto-reconnect and connection lost, in which, stream is screwed anyway
                        stream.close({ error }).catch(onStreamCloseError);
                    });
                    return;
                }
                stream.isActive = false;
            }
            if (message.type === "complete") {
                stream.onMessage({ type: "complete" }, stream);
                stream.isActive = false;
            }
            this.debug("About to close stream [%s] due to GraphQL '%s' message.", stream.id, message.type);
            const closeError = message.type === "error" ? message.payload : undefined;
            stream.close({ error: closeError }).catch(onStreamCloseError);
        });
        this.handleReconnection = () => {
            this.debug("Handling re-connection notification from socket.");
            if (this.autoRestartStreamsOnReconnect === false) {
                return;
            }
            this.connectionEstablisher
                .establish(this.apiToken, this.socket)
                .then(() => {
                return Promise.all(Object.keys(this.streams).map((id) => this.streams[id].restart()));
            })
                .catch((error) => __awaiter(this, void 0, void 0, function* () {
                const finalizer = () => {
                    // FIXME: We shall pass this error somewhere, to some kind of notifier or event
                    //        emitter but there is no such stuff right now.
                    this.debug("The re-connection failed to re-establish the GraphQL connection %O", error);
                };
                return Promise.all(Object.keys(this.streams).map((id) => this.streams[id].close({ error })))
                    .then(finalizer)
                    .catch(finalizer);
            }));
        };
        this.socket = socket;
        this.autoRestartStreamsOnReconnect = autoRestartStreamsOnReconnect;
        this.autoRestartStreamsOnError = autoRestartStreamsOnError;
        this.restartOnErrorDelayInMs = restartOnErrorDelayInMs;
        this.autoDisconnectSocket = autoDisconnectSocket;
        this.connectionEstablisher = new GraphqlConnectionEstablisher(this.debug);
    }
    release() {
        this.debug("Terminating connection & releasing default GraphQL stream client");
        this.socket.disconnect().catch((error) => {
            this.debug("An error occurred while disconnecting from socket while releasing instance", error);
        });
    }
    setApiToken(apiToken) {
        this.apiToken = apiToken;
    }
    registerStream(id, document, variables, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.socket.isConnected) {
                this.debug("Socket is not connected, connecting socket first.");
                yield this.socket.connect(this.handleMessage, { onReconnect: this.handleReconnection });
                yield this.connectionEstablisher.establish(this.apiToken, this.socket);
            }
            if (this.streams[id] !== undefined) {
                throw new DfuseClientError(`A stream with id '${id}' is already registered, cannot register another one with the same id`);
            }
            this.debug("Registering stream [%s]", id);
            const streamExists = (streamId) => this.streams[streamId] !== undefined;
            const unregisterStream = (streamId) => this.unregisterStream(streamId);
            const stream = new DefaultGraphqlStream(id, document, variables, onMessage, streamExists, unregisterStream, this.socket, this.debug);
            // Let's first register stream to ensure that if messages arrives before we got back
            // execution flow after `send` call, the listener is already present to handle message
            this.streams[id] = stream;
            try {
                yield stream.start();
            }
            catch (error) {
                delete this.streams[id];
                throw new DfuseClientError(`Unable to correctly register stream '${id}'`, error);
            }
            this.debug("Stream [%s] registered with remote endpoint.", id);
            return stream;
        });
    }
    unregisterStream(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = this.streams[id];
            if (stream === undefined) {
                this.debug("Stream [%s] is already unregistered, nothing to do.", id);
                return;
            }
            this.debug("Unregistering stream [%s].", id);
            delete this.streams[id];
            try {
                if (stream.isActive && this.socket.isConnected) {
                    yield this.socket.send({ id, type: "stop" });
                }
                if (Object.keys(this.streams).length <= 0 && this.autoDisconnectSocket) {
                    this.debug("No more stream present and auto disconnect sets to true, terminating connection & disconnecting socket.");
                    if (this.socket.isConnected) {
                        yield this.socket.disconnect();
                    }
                }
                stream.onUnregister();
            }
            catch (error) {
                stream.onUnregister(error);
                throw error;
            }
        });
    }
}
class DefaultGraphqlStream {
    constructor(id, registrationDocument, registrationVariables, onMessage, streamExists, unregisterStream, socket, debug) {
        this.resolve = () => {
            if (this.activeJoiner) {
                this.debug("Resolving joiner promise for stream [%s].", this.id);
                this.activeJoiner.resolve();
            }
        };
        this.reject = (error) => {
            if (this.activeJoiner) {
                this.debug("Rejecting joiner promise for stream [%s] with error %o.", this.id, error);
                this.activeJoiner.reject(error);
            }
        };
        this.id = id;
        this.active = false;
        this.registrationDocument = registrationDocument;
        this.registrationVariables = registrationVariables;
        this.onMessageHandler = onMessage;
        this.streamExists = streamExists;
        this.unregisterStream = unregisterStream;
        this.socket = socket;
        this.debug = debug;
    }
    get isActive() {
        return this.active;
    }
    set isActive(value) {
        this.active = value;
    }
    get onMessage() {
        return this.onMessageHandler;
    }
    currentActiveMarker() {
        return this.activeMarker;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield this.createStartMessage();
            if (message.payload.variables !== undefined) {
                message.payload.variables = Object.assign({ cursor: "" }, message.payload.variables);
            }
            return this.socket.send(message).then(() => {
                this.active = true;
            });
        });
    }
    restart(marker) {
        return __awaiter(this, void 0, void 0, function* () {
            this.debug("About to restart stream [%s]", this.id);
            this.checkMarker(marker);
            if (!this.streamExists(this.id)) {
                throw new DfuseClientError(`Trying to restart a stream '${this.id}' that is not registered anymore or was never registered`);
            }
            let activeMarker = this.activeMarker;
            if (marker) {
                activeMarker = marker;
            }
            const message = yield this.createStartMessage();
            if (activeMarker) {
                message.payload.variables = Object.assign(Object.assign({}, (message.payload.variables || {})), { 
                    // @ts-ignore The `cursor` field is the only possibility here, it's just TypeScript can't discriminate it
                    cursor: activeMarker.cursor });
            }
            yield this.socket.send(message).then(() => {
                this.active = true;
            });
            if (this.onPostRestart) {
                this.onPostRestart();
            }
        });
    }
    createStartMessage() {
        return __awaiter(this, void 0, void 0, function* () {
            let resolvedVariables = this.registrationVariables;
            if (typeof resolvedVariables === "function") {
                // We use `as any` here because the docs builder which uses TypeScript 3.2.4 chokes on this line due to hard typing.
                // At some point, the `typedoc` will be updated and the error should resolves itself. Simply remove the cast and
                // regenerate the docs `yarn build:docs` to test if it's fixed or not.
                resolvedVariables = yield resolvedVariables();
            }
            return {
                id: this.id,
                type: "start",
                payload: {
                    query: this.registrationDocument,
                    variables: Object.assign({ cursor: "" }, (resolvedVariables || {}))
                }
            };
        });
    }
    join() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeJoiner !== undefined) {
                return this.activeJoiner.promise();
            }
            this.activeJoiner = new Deferred();
            return this.activeJoiner.promise();
        });
    }
    mark(marker) {
        this.activeMarker = this.checkMarker(marker);
    }
    close(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            this.closeError = options.error;
            return yield this.unregisterStream(this.id);
        });
    }
    checkMarker(marker) {
        if (!marker) {
            return undefined;
        }
        if (!marker.cursor) {
            throw new DfuseClientError("Only non-empty `cursor` markers are accepted for this operation");
        }
        return marker;
    }
    // Public only for the stream client to be able to call us directly. Not best practice but since
    // the client and his streams are tighly coupled, cohesion makes sense here. Will never be seen
    // by a consumer anyway and this method is not part of any backward compatibility policy.
    onUnregister(unregisterError) {
        // FIXME: We should probably return a MultiError of some kind to report both of
        //        `unregisterError` and `this.closeError` if they are both set.
        if (unregisterError) {
            this.reject(unregisterError);
        }
        else if (this.closeError) {
            this.reject(this.closeError);
        }
        else {
            this.resolve();
        }
    }
}
class GraphqlConnectionEstablisher {
    constructor(debug) {
        this.debug = debug;
    }
    establish(apiToken, socket) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.activeDeferred !== undefined) {
                return this.activeDeferred.promise();
            }
            this.activeDeferred = new Deferred();
            this.activeSocket = socket;
            this.debug("Initiating graphql stream connection");
            socket.send({
                type: "connection_init",
                payload: {
                    Authorization: apiToken
                }
            });
            return this.activeDeferred.promise();
        });
    }
    onMessage(message) {
        if (this.activeDeferred === undefined) {
            return;
        }
        if (message.type === "connection_ack") {
            this.debug("Received connection_ack message, resolving active promise");
            this.resolve();
            return;
        }
        if (message.type === "connection_error") {
            this.debug("Received connection_error message %O, rejecting active promise", message.payload);
            this.reject(message.payload);
            return;
        }
        this.debug("Received an unknown message while waiting for graphql connection to establish, something is fishy %O", message);
    }
    resolve() {
        if (this.activeDeferred === undefined) {
            return;
        }
        this.debug("Resolving connection establisher deferred promise.");
        this.activeDeferred.resolve();
        this.activeDeferred = undefined;
    }
    reject(error) {
        const complete = () => {
            if (this.activeDeferred !== undefined) {
                this.debug("Rejecting connection establisher deferred promise.");
                this.activeDeferred.reject(error);
                this.activeDeferred = undefined;
            }
        };
        if (this.activeSocket && this.activeSocket.isConnected) {
            this.activeSocket
                .disconnect()
                .then(complete)
                .catch(complete);
        }
        else {
            complete();
        }
    }
}

function createRefreshScheduler() {
    return new DefaultRefreshScheduler();
}
class DefaultRefreshScheduler {
    constructor() {
        this.debug = debugFactory("dfuse:refresh-scheduler");
    }
    release() {
        this.debug("Releasing default refresh scheduler");
        if (this.renewalTimeout !== undefined) {
            this.debug("Clearing refresh timeout interval");
            this.clearRefreshTimeout();
        }
    }
    hasScheduledJob() {
        return this.renewalTimeout !== undefined;
    }
    schedule(delayInSeconds, job, onJobFailed) {
        if (delayInSeconds <= 0) {
            this.debug("Delay in seconds should be greater than 0");
            return;
        }
        if (this.renewalTimeout) {
            this.debug("Clearing previous sheduled timer");
            this.clearRefreshTimeout();
        }
        this.renewalTimeout = setTimeout(() => {
            try {
                this.debug("Executing scheduled job at %s%O", new Date(), job);
                job();
            }
            catch (error) {
                this.debug("Scheduled job failed (%o)", error);
                if (onJobFailed) {
                    onJobFailed(error);
                }
            }
            this.clearRefreshTimeout();
        }, delayInSeconds * 1000);
    }
    clearRefreshTimeout() {
        clearTimeout(this.renewalTimeout);
        this.renewalTimeout = undefined;
    }
}

const MAX_UINT32_INTEGER = 2147483647;
// Small module wide variable incremented each time a client instance is created
let clientInstanceId = 0;
/**
 * The main entry point of the library, use it to create the standard [[DfuseClient]]
 * instance.
 *
 * Only the `apiKey` and `network` parameters are mandatory, all others have sane
 * default values based on your execution environment (be it a Browser or Node.js).
 *
 * This will create the default
 *
 * @param options The options that can be passed to customize [[DfuseClient]] instance,
 * refer to the [[DfuseClientOptions]] for further details.
 *
 * @kind Factories
 */
function createDfuseClient(options) {
    checkApiKey(options.apiKey);
    const endpoint = networkToEndpoint(options.network);
    const secureEndpoint = options.secure === undefined ? true : options.secure;
    const authUrl = options.authUrl || "https://auth.dfuse.io";
    const restUrl = secureEndpoint ? `https://${endpoint}` : `http://${endpoint}`;
    const websocketUrl = secureEndpoint ? `wss://${endpoint}` : `ws://${endpoint}`;
    const endpoints = {
        authUrl,
        graphqlQueryUrl: `${restUrl}/graphql`,
        graphqlStreamUrl: `${websocketUrl}/graphql`,
        restUrl,
        websocketUrl
    };
    const httpClient = options.httpClient || createHttpClient(authUrl, restUrl, options.httpClientOptions);
    const streamClient = options.streamClient ||
        createStreamClient(websocketUrl + "/v1/stream", options.streamClientOptions);
    const graphqlStreamClient = options.graphqlStreamClient ||
        createGraphqlStreamClient(endpoints.graphqlStreamUrl, options.graphqlStreamClientOptions);
    const apiTokenStore = options.apiTokenStore || inferApiTokenStore(options.apiKey);
    const refreshScheduler = options.refreshScheduler || createRefreshScheduler();
    const requestIdGenerator = options.requestIdGenerator || randomReqId;
    return new DefaultClient(clientInstanceId++, options.apiKey, endpoints, httpClient, streamClient, graphqlStreamClient, apiTokenStore, refreshScheduler, requestIdGenerator);
}
// Even though higher the type say it cannot be empty, this is usually provided
// by the user and as such, as assume it could be undefined.
function checkApiKey(apiKey) {
    if (apiKey == null) {
        const messages = [
            "The client must be configured with an API key via the ",
            "`apiKey` config options.",
            "",
            "Received nothing."
        ];
        throw new DfuseError(messages.join("\n"));
    }
    if (!apiKey.match(/^(mobile|server|web)_[0-9a-f]{2,}/i)) {
        const messages = [
            "The provided API key is not in the right format, expecting it",
            "to start with either `mobile_`, `server_` or `web_` followed",
            "by a series of hexadecimal character (i.e.) `web_0123456789abcdef`)",
            ""
        ];
        // Assume it's an API token if looks (roughly) like a JWT token
        if (apiKey.split(".").length === 3) {
            messages.push("It seems your providing directly a API token (JWT) instead", "of an API key and are using your previous authentication protocol.", "Please refer to http://docs.dfuse.io/#authentication for", "all the details about API key and how to generate an API token", "from it.", "", "And you can visit https://app.dfuse.io to obtain your free API key", "");
        }
        messages.push(`Input received: ${apiKey}`);
        throw new DfuseError(messages.join("\n"));
    }
}
function inferApiTokenStore(apiKey) {
    const debug = debugFactory("dfuse:client");
    debug("Inferring API token store default concrete implementation to use");
    if (typeof window !== "undefined" && window.localStorage != null) {
        debug('Using `LocalStorageApiTokenStore` as we assumed a Browser environment (`typeof window.localStorage !== "undefined"`).');
        return new LocalStorageApiTokenStore("dfuse:token");
    }
    // Just in the sake that `window.localStorage` is not supported for whatever, fall
    // back to Node.js default only if we are really in a Node.js like environment.
    if (typeof window === "undefined") {
        debug('Using `OnDiskLocalStorageApiTokenStore` as we assumed a Node.js enviroment (`typeof window === "undefined"`).');
        return new OnDiskApiTokenStore(apiKey);
    }
    debug("Falling back default `InMemoryApiTokenStore` concrete implementation");
    return new InMemoryApiTokenStore();
}
function networkToEndpoint(network) {
    if (network === "mainnet" ||
        network === "jungle" ||
        network === "kylin" ||
        network === "worbli") {
        return `${network}.eos.dfuse.io`;
    }
    // Network is assumed to be an hostname to reach the dfuse service
    return network;
}
/**
 * The standard implementation of a [[DfuseClient]].
 *
 * The [[DefaultClient]] role is to perform the API key management
 * functionalities of the client. It retrieves an API token using the
 * API key and ensures it stays valid throughout the lifecycle of the
 * client, refreshing the token when necessary.
 *
 * It also responsible of keep and up-to-date list of streams and managing
 * the re-connection to those stream when the websocket disconnects.
 *
 * It is supported to override the client to provide some other
 * methods on it (other EOS endpoints).
 */
class DefaultClient {
    constructor(id, apiKey, endpoints, httpClient, streamClient, graphqlStreamClient, apiTokenStore, refreshScheduler, requestIdGenerator) {
        this.debug = debugFactory("dfuse:client");
        this.withDefaultOptions = (options) => {
            return Object.assign({ req_id: `${this.requestIdGenerator()}-${this.id}` }, options);
        };
        this.onTokenRefresh = (apiToken) => {
            // Ensure we update the API token to have it at its latest value
            this.streamClient.setApiToken(apiToken);
            this.graphqlStreamClient.setApiToken(apiToken);
        };
        this.id = id;
        this.apiKey = apiKey;
        this.endpoints = endpoints;
        this.httpClient = httpClient;
        this.streamClient = streamClient;
        this.graphqlStreamClient = graphqlStreamClient;
        this.requestIdGenerator = requestIdGenerator;
        if (this.endpoints.authUrl.startsWith("null://")) {
            this.apiTokenManager = createNoopApiTokenManager("a.b.c");
        }
        else {
            this.apiTokenManager = createApiTokenManager(() => this.authIssue(this.apiKey), this.onTokenRefresh, 0.95, apiTokenStore, refreshScheduler);
        }
    }
    release() {
        this.debug("Releasing default dfuse client");
        this.httpClient.release();
        this.streamClient.release();
        this.graphqlStreamClient.release();
        this.apiTokenManager.release();
    }
    //
    /// GraphQL API
    //
    // The return type has `Promise<GraphqlResponse<T> | Stream | any>`. The `any` sadly is an
    // artefact to please the compiler. Without it, the compiler thinks the resulting type is
    // not a proper implementation of `DfuseClient.graphql` which has two signatures, both of them
    // being of a different return type.
    graphql(document, onMessage, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof onMessage !== "function" && onMessage) {
                options = onMessage;
            }
            if (options.operationType && !isValidDocumentType(options.operationType)) {
                throw new DfuseError(`The 'options.operationType' value '${options.operationType}' is invalid, it must be either 'query', 'mutation' or 'subscription').`);
            }
            // If an `onMessage` options is provided, always use the WebSocket connection
            const onMessageProvided = typeof onMessage === "function" && onMessage;
            if (onMessageProvided) {
                return this.withApiToken((apiTokenInfo) => {
                    this.graphqlStreamClient.setApiToken(apiTokenInfo.token);
                    return this.graphqlStreamClient.registerStream(`${this.requestIdGenerator()}-${this.id}`, 
                    // FIXME: Turn the document if a GraphQL document into a proper document string
                    document, options.variables, onMessage);
                });
            }
            const operationType = this.inferOperationType(document, options.operationType);
            if (!operationType && !onMessageProvided) {
                const messages = [
                    "We were not able to infer the GraphQL operation type you are trying to perform from",
                    "the document and options you provided. Without the document's operation type, we are",
                    "unable to determine the transport layer to use to execute your operation, either HTTP",
                    "or WebSocket transport.",
                    "",
                    "If you passed a document as a plain 'string' value, please use the `options.operationType`",
                    "option to provide the operation type to perform. You can also use the 'gql' string literal",
                    "processor to turn your string into a rich Document, on which inference always work.",
                    "",
                    "If you already provided the document a rich Document format via the 'gql` ...`' call, then it's",
                    "probably a bug in this library. You can provide the `options.operationType` option to workaround",
                    "the problem and report the bug to us with the document string used.",
                    "",
                    "Valid `options.operationType` values are either 'query', 'mutation' or 'subscription'.",
                    "",
                    "You can also force usage of WebSocket transport by providing the `options.onMessage` which",
                    "forces the usage of the WebSocket transport."
                ];
                throw new DfuseError(messages.join("\n"));
            }
            if (operationType === "subscription" && !onMessageProvided) {
                const messages = [
                    "The `options.onMessage` parameter is required for 'subscription' document.",
                    "If your document is not a 'subscription' type, this is probably a bug with the library.",
                    "You can provide the `options.operationType` option to workaroundthe problem and report",
                    "the bug to us with the document string used."
                ];
                throw new DfuseError(messages.join("\n"));
            }
            // FIXME: Turn the document into a proper document string if a GraphQL document
            return yield this.apiRequest("/graphql", "POST", {}, { query: document, variables: options.variables });
        });
    }
    //
    /// WebSocket API
    //
    streamActionTraces(data, onMessage, options = {}) {
        return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => messageCreator(OutboundMessageType.GET_ACTION_TRACES, data, withDefaultOptions(Object.assign({ listen: true }, options))));
    }
    streamTableRows(data, onMessage, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => messageCreator(OutboundMessageType.GET_TABLE_ROWS, Object.assign({ json: true }, data), withDefaultOptions(Object.assign({ listen: true }, options))));
        });
    }
    streamTransaction(data, onMessage, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => messageCreator(OutboundMessageType.GET_TRANSACTION_LIFECYCLE, data, withDefaultOptions(Object.assign({ listen: true, fetch: true }, options))));
        });
    }
    streamHeadInfo(onMessage, options = {}) {
        return this.websocketStream(onMessage, (messageCreator, withDefaultOptions) => {
            return messageCreator(OutboundMessageType.GET_HEAD_INFO, {}, withDefaultOptions(Object.assign({ listen: true }, options)));
        });
    }
    websocketStream(onMessage, initMessageFactory) {
        const message = initMessageFactory(createOutboundMessage, this.withDefaultOptions);
        return this.registerStream(message, onMessage);
    }
    //
    /// HTTP API
    //
    authIssue(apiKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.httpClient.authRequest(V1_AUTH_ISSUE, "POST", undefined, {
                api_key: apiKey
            });
        });
    }
    fetchBlockIdByTime(time, comparator) {
        return __awaiter(this, void 0, void 0, function* () {
            let timeString = time;
            if (time instanceof Date) {
                timeString = time.toISOString();
            }
            return this.apiRequest(V0_FETCH_BLOCK_ID_BY_TIME, "GET", {
                time: timeString,
                comparator
            });
        });
    }
    fetchTransaction(id) {
        // TODO: Should we properly URL encode the transaction id?
        return this.apiRequest(V0_FETCH_TRANSACTION.replace(":id", id), "GET");
    }
    searchTransactions(q, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_SEARCH_TRANSACTIONS, "GET", {
                q,
                start_block: options.startBlock,
                sort: options.sort,
                block_count: options.blockCount === undefined ? MAX_UINT32_INTEGER : options.blockCount,
                limit: options.limit,
                cursor: options.cursor,
                with_reversible: options.withReversible
            });
        });
    }
    stateAbi(account, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_ABI, "GET", {
                account,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json
            });
        });
    }
    stateAbiBinToJson(account, table, hexRows, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_ABI_BIN_TO_JSON, "POST", undefined, {
                account,
                table,
                hex_rows: hexRows,
                block_num: options.blockNum
            });
        });
    }
    stateKeyAccounts(publicKey, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_KEY_ACCOUNTS, "GET", {
                public_key: publicKey,
                block_num: options.blockNum
            });
        });
    }
    statePermissionLinks(account, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_PERMISSION_LINKS, "GET", {
                account,
                block_num: options.blockNum
            });
        });
    }
    stateTableScopes(account, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_TABLE_SCOPES, "GET", {
                account,
                table,
                block_num: options.blockNum
            });
        });
    }
    stateTable(account, scope, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_TABLE, "GET", {
                account,
                scope,
                table,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            });
        });
    }
    stateTableRow(account, scope, table, primaryKey, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_TABLE_ROW, "GET", {
                account,
                scope,
                table,
                primary_key: primaryKey,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            });
        });
    }
    stateTablesForAccounts(accounts, scope, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_TABLES_ACCOUNTS, "POST", undefined, {
                accounts: accounts.join("|"),
                scope,
                table,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            }, {
                "Content-Type": "application/x-www-form-urlencoded"
            });
        });
    }
    stateTablesForScopes(account, scopes, table, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiRequest(V0_STATE_TABLES_SCOPES, "POST", undefined, {
                account,
                scopes: scopes.join("|"),
                table,
                block_num: options.blockNum,
                json: options.json === undefined ? true : options.json,
                key_type: options.keyType,
                with_block_num: options.withBlockNum,
                with_abi: options.withAbi
            }, {
                "Content-Type": "application/x-www-form-urlencoded"
            });
        });
    }
    apiRequest(path, method, params, body, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.withApiToken((apiTokenInfo) => {
                return this.httpClient.apiRequest(apiTokenInfo.token, path, method, params, body, headers);
            });
        });
    }
    getTokenInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.apiTokenManager.getTokenInfo();
        });
    }
    registerStream(message, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.withApiToken((apiTokenInfo) => {
                this.streamClient.setApiToken(apiTokenInfo.token);
                return this.streamClient.registerStream(message, onMessage);
            });
        });
    }
    withApiToken(worker) {
        return __awaiter(this, void 0, void 0, function* () {
            let apiTokenInfo;
            try {
                this.debug("Retrieving latest API token via token manager");
                apiTokenInfo = yield this.apiTokenManager.getTokenInfo();
            }
            catch (error) {
                throw new DfuseClientError("Unable to obtain the API token", error);
            }
            return yield worker(apiTokenInfo);
        });
    }
    inferOperationType(document, predefinedOperationType) {
        this.debug("Trying to infer operation type based on document and predefined operation type, predefined operation type '%s' and document %o", predefinedOperationType, document);
        if (predefinedOperationType) {
            this.debug("Predefined type '%s' provided, using it straight away.", predefinedOperationType);
            return predefinedOperationType;
        }
        if (typeof document === "string") {
            this.debug("Document is a plain string type, performing a poor-man Regex extraction.");
            const matches = document.match(/^\s*(query|mutation|subscription)?\s*([_A-Za-z][_0-9A-Za-z]*\s*)?(\([^\)]*\)\s*)?{/);
            if (matches == null) {
                this.debug("Document string did not match our Regex, aborting inference.");
                return undefined;
            }
            if (matches && matches[1]) {
                this.debug("Document string Regex matches have operation type '%s', using it.", matches[1]);
                return matches[1];
            }
            this.debug("Document string Regex matches but operation type was not present, using 'query'.");
            return "query";
        }
        // FIXME: Make the initial AST walking and work our way through!
        return undefined;
    }
}
function isValidDocumentType(type) {
    if (!type) {
        return false;
    }
    return type === "subscription" || type === "query" || type === "mutation";
}
function randomReqId() {
    return `dc-${Math.random()
        .toString(16)
        .substr(2)}`;
}

/**
 * This small utility is useful to implement a dynamic dispatcher
 * based on the type of message. That is usefull to avoid having to
 * code yourself a `switch (message.type) { ... }` switch case.
 *
 * Instead, define a series of specific of handlers on a class or
 * an object, then when calling the stream method of your choices,
 * pass the dynamic dispatcher created by calling this method as
 * the message handler.
 *
 * The created dispatcher upon each message, will check the received
 * type to handler map and will dispatch it there.
 *
 * ```
 * const dispatch = dynamicMessageDispatcher({
 *   listening: this.onListening,
 *   progress: this.onProgress,
 *   action_trace: this.onAction,
 * })
 *
 * client.streamActionTraces({ ... }, dispatcher)
 * ```
 */
function dynamicMessageDispatcher(typeToDispatcher) {
    return (message, stream) => {
        const dispatcher = typeToDispatcher[message.type];
        if (dispatcher) {
            dispatcher(message, stream);
        }
    };
}

/**
 * This method flattens the nested action traces of a [[TransactionLifecycle]] into
 * a single flat list. The flat list indexes matches dfuse API action index
 * which is used within dfuse to identify particular action trace in
 * various situation (db ops, RAM ops, etc).
 *
 * The action index of a given action is obtained simply by doing a
 * deep-first traversal of the action traces structure incrementing
 * a counter at each step and binding the counter to the current traversed
 * action becoming the action's index.
 *
 * As an example of this method, assume the following transaction:
 *
 * ```
 * Transaction 123 {
 *   ExecutionTrace {
 *     ActionTraces: [
 *       ActionTrace(eosio.token/eosio.token:transfer) {
 *         InlineTraces: [
 *           ActionTrace(from/eosio.token:transfer) {
 *             InlineTraces: [
 *               ActionTrace(contractX/contractX:log)
 *             ]
 *           }
 *           ActionTrace(to/eosio.token:transfer) {
 *             InlineTraces: [
 *               ActionTrace(contractY/contractY:update)
 *             ]
 *           }
 *         ]
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * This will results in the following flattened actions list being returned:
 *
 * ```
 * [
 *   ActionTrace(eosio.token/eosio.token:transfer),
 *   ActionTrace(from/eosio.token:transfer),
 *   ActionTrace(contractX/contractX:log),
 *   ActionTrace(to/eosio.token:transfer),
 *   ActionTrace(contractY/contractY:update),
 * ]
 * ```
 *
 * @param transaction The transaction lifecycle object to flatten action traces from.
 * @returns A flat list of action traces extracted from the transaction lifecycle for which each
 * index of the list represents the action's index concept of dfuse API.
 */
function flattenActionTraces(transaction) {
    if (!transaction.execution_trace) {
        return [];
    }
    const state = {
        index: -1,
        actions: []
    };
    transaction.execution_trace.action_traces.forEach((actionTrace) => {
        walkFlattenedActionTraces(actionTrace, state);
    });
    return state.actions;
}
function walkFlattenedActionTraces(rootActionTrace, state) {
    state.index++;
    state.actions.push(rootActionTrace);
    const childActionTraces = rootActionTrace.inline_traces || [];
    childActionTraces.forEach((childActionTrace) => {
        walkFlattenedActionTraces(childActionTrace, state);
    });
}
/**
 * This method extracts the matchinf actions out of [[SearchTransactionRow]]
 * object.
 *
 * Using the search endpoint, you receives a [[SearchTransactionRow]] that
 * is simply a composite object containing an actual [[TransactionLifecycle]]
 * element as well as a list of action indexes which are the actual
 * ones that matched your query.
 *
 * A single transaction can contains a big amount of actions but usually,
 * only a subset of the actions in a transaction matches your search query.
 *
 * By using this method, you can easily extracts the matching actions
 * out of the [[SearchTransactionRow]] object.
 *
 * @param searchRow The search result row to extract matching action traces from.
 * @returns A flat list of action traces extracted from the search result row that matched
 * the query term(s).
 */
function matchingActionTraces(searchRow) {
    if (!searchRow.lifecycle.execution_trace) {
        return [];
    }
    const matchingActionIndexes = searchRow.action_idx;
    const state = {
        index: -1,
        actions: []
    };
    searchRow.lifecycle.execution_trace.action_traces.forEach((actionTrace) => {
        walkMatchingActionTraces(actionTrace, matchingActionIndexes, state);
    });
    return state.actions;
}
function walkMatchingActionTraces(rootActionTrace, matchingActionIndexes, state) {
    state.index++;
    if (matchingActionIndexes.includes(state.index)) {
        state.actions.push(rootActionTrace);
    }
    const childActionTraces = rootActionTrace.inline_traces || [];
    childActionTraces.forEach((childActionTrace) => {
        walkMatchingActionTraces(childActionTrace, matchingActionIndexes, state);
    });
}

export { DEFAULT_DELAY_BUFFER_PERCENT, DEFAULT_KEEP_ALIVE_INTERVAL_IN_MS, DEFAULT_RECONNECT_DELAY_IN_MS, DefaultClient, DfuseApiError, DfuseClientError, DfuseError, DfuseSocketError, FileApiTokenStore, InMemoryApiTokenStore, InboundMessageType, LocalStorageApiTokenStore, OnDiskApiTokenStore, OutboundMessageType, V0_FETCH_BLOCK_ID_BY_TIME, V0_FETCH_TRANSACTION, V0_SEARCH_TRANSACTIONS, V0_STATE_ABI, V0_STATE_ABI_BIN_TO_JSON, V0_STATE_KEY_ACCOUNTS, V0_STATE_PERMISSION_LINKS, V0_STATE_TABLE, V0_STATE_TABLES_ACCOUNTS, V0_STATE_TABLES_SCOPES, V0_STATE_TABLE_ROW, V0_STATE_TABLE_SCOPES, V1_AUTH_ISSUE, createApiTokenManager, createDfuseClient, createHttpClient, createNoopApiTokenManager, createOutboundMessage, createRefreshScheduler, createSocket, createStreamClient, dynamicMessageDispatcher, flattenActionTraces, getActionTracesMessage, getHeadInfoMessage, getTableRowsMessage, getTransactionLifecycleMessage, isApiTokenExpired, matchingActionTraces, networkToEndpoint, unlistenMessage, waitFor };
//# sourceMappingURL=dfuse-client.es5.js.map
